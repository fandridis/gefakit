This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
apps/
  api/
    public/
      index.html
    src/
      db/
        migrations/
          0001_init.ts
          0002_user.ts
          0003_todo.ts
          0004_todo_add_created_at.ts
        seeds/
          first.ts
          second.ts
          seed-runner.ts
        db-types.d.ts
        migrate-down.ts
        migrate.ts
      errors/
        app-error.ts
        index.ts
      features/
        auth/
          auth.controller.ts
          auth.errors.ts
          auth.repository.ts
          auth.routes.v1.ts
          auth.service.ts
          pwned.ts
        persons/
          person.routes.v1.ts
        todos/
          todo.controller.ts
          todo.errors.ts
          todo.repository.ts
          todo.routes.v1.ts
          todo.service.ts
      lib/
        zod-utils.ts
      middleware/
        auth.ts
        db.ts
      types/
        hono.ts
      index.ts
    .gitignore
    package.json
    README.md
    tsconfig.json
    wrangler.jsonc
  web/
    src/
      components/
        form/
          components/
            field-info.tsx
            field-label.tsx
            submit-button.tsx
            submit-checkbox.tsx
            text-input.tsx
          form-context.tsx
          form.tsx
        ui/
          button.tsx
          checkbox.tsx
          input.tsx
          label.tsx
      features/
        auth/
          hooks/
            useAuth.ts
            useAuthActions.ts
            useAuthSession.ts
          api.ts
        todos/
          components/
            todo-view.tsx
          hooks/
            useTodos.ts
          api.ts
      lib/
        utils.ts
      App.css
      App.tsx
      index.css
      main.tsx
      vite-env.d.ts
    worker/
      index.ts
    .gitignore
    components.json
    eslint.config.js
    index.html
    package.json
    README.md
    tsconfig.app.json
    tsconfig.json
    tsconfig.node.json
    tsconfig.worker.json
    vite.config.ts
    wrangler.jsonc
packages/
  shared/
    src/
      schemas/
        auth.schema.ts
        todo.schema.ts
      types/
        auth.ts
        todo.ts
        user.ts
      index.ts
    .gitignore
    package.json
    tsconfig.json
.gitignore
.repomixignore
package.json
pnpm-workspace.yaml
README.md
repomix.config.json

================================================================
Files
================================================================

================
File: apps/api/src/db/migrations/0003_todo.ts
================
import { Kysely } from 'kysely';

export async function up(db: Kysely<any>): Promise<void> {
  await db.schema
    .createTable('todo')
    .addColumn('id', 'serial', col => col.primaryKey())
    .addColumn('title', 'varchar', col => col.notNull())
    .addColumn('description', 'varchar')
    .addColumn('due_date', 'timestamp')
    .addColumn('completed', 'boolean', col => col.defaultTo(false).notNull())
    .addColumn('author_id', 'integer', col => col.references('app_user.id').notNull())
    .execute();
}

export async function down(db: Kysely<any>): Promise<void> {
  await db.schema.dropTable('todo').execute();
}

================
File: apps/api/src/db/migrations/0004_todo_add_created_at.ts
================
import { Kysely, sql } from 'kysely';

export async function up(db: Kysely<any>): Promise<void> {
  await db.schema
    .alterTable('todo')
    .addColumn('created_at', 'timestamp', (col) =>
      col.defaultTo(sql`now()`).notNull()
    )
    .execute();
}

export async function down(db: Kysely<any>): Promise<void> {
  await db.schema.alterTable('todo').dropColumn('created_at').execute();
}

================
File: apps/api/src/db/seeds/second.ts
================
// seed.ts

import { Kysely } from 'kysely'
import { DB } from '../db-types'
import { config } from 'dotenv'
import { NeonDialect } from 'kysely-neon'
import { faker } from '@faker-js/faker'

// Choose a config file based on NODE_ENV
const env = process.env.NODE_ENV || 'development'
const envFile =
  env === 'production'
    ? '.dev.vars.production'
    : env === 'staging'
    ? '.dev.vars.staging'
    : '.dev.vars'

// Load environment variables from the appropriate file
config({ path: envFile })

async function seed() {
  const db = new Kysely<DB>({
    dialect: new NeonDialect({
      connectionString: process.env.DATABASE_URL,
    }),
  })

  // Generate 100 todo items
  const todos = []
  for (let i = 0; i < 100; i++) {
    todos.push({
      title: faker.lorem.sentence(),
      description: faker.lorem.paragraph(),
      due_date: faker.date.future(),
      completed: faker.datatype.boolean(),
      author_id: 12,
    })
  }

  // Insert todos into the database
  await db.insertInto('todo').values(todos).execute()

  console.log('Database seeded successfully with 100 todos!')
  await db.destroy()
}

seed().catch((error) => {
  console.error('Failed to seed database:', error)
  process.exit(1)
})

================
File: apps/api/src/db/seeds/seed-runner.ts
================
// src/db/seed-runner.ts
import { existsSync } from 'fs';
import { join } from 'path';

// Allowed environments
const allowedEnvs = ['dev', 'staging', 'production-yes-i-am-sure'];

// Simple argument parsing for --env and --filepath
let env: string | undefined;
let fileName: string | undefined;

for (const arg of process.argv.slice(2)) {
  if (arg.startsWith('--env=')) {
    env = arg.split('=')[1];
  }
  if (arg.startsWith('--file=')) {
    fileName = arg.split('=')[1];
  }
}

// Validate env
if (!env) {
  console.error('Error: Missing required argument --env. Allowed values are: dev, staging, production-yes-i-am-sure.');
  process.exit(1);
}

if (!allowedEnvs.includes(env)) {
  console.error(`Error: Invalid env value "${env}". Allowed values are: ${allowedEnvs.join(', ')}.`);
  process.exit(1);
}

// Validate fileName
if (!fileName) {
  console.error('Error: Missing required argument --file. Please provide a seed file name.');
  process.exit(1);
}

// Construct the full path to the seed file (assuming files are in src/db/seeds)
const seedFilePath = join(__dirname, fileName);
if (!existsSync(seedFilePath)) {
  console.error(`Error: Seed file "${seedFilePath}" does not exist.`);
  process.exit(1);
}

// Dynamically import and run the seed file
(async () => {
  try {
    await import(seedFilePath);
    console.log(`Successfully ran seed file: ${fileName} in ${env} environment`);
  } catch (error) {
    console.error(`Error running seed file "${fileName}":`, error);
    process.exit(1);
  }
})();

================
File: apps/api/src/db/migrate-down.ts
================
import * as path from 'path'
import { promises as fs } from 'fs'
import {
  Kysely,
  Migrator,
  FileMigrationProvider,
} from 'kysely'
import { NeonDialect } from 'kysely-neon'
import { config } from 'dotenv'

// Choose a config file based on NODE_ENV
const env = process.env.NODE_ENV || 'development'
const envFile =
  env === 'production'
    ? '.dev.vars.production'
    : env === 'staging'
    ? '.dev.vars.staging'
    : '.dev.vars'

// Load environment variables from the appropriate file
config({ path: envFile })

async function migrateToLatest() {

    console.log('process.env.DATABASE_URL: ', process.env.DATABASE_URL)

    const db = new Kysely<any>({
        dialect: new NeonDialect({
            connectionString: process.env.DATABASE_URL,
        }),
    })

    const migrator = new Migrator({
        db,
        provider: new FileMigrationProvider({
        fs,
        path,
        // This needs to be an absolute path.
        migrationFolder: path.join(__dirname, 'migrations'),
        }),
    })

    const { error, results } = await migrator.migrateDown()

    results?.forEach((it) => {
        if (it.status === 'Success') {
        console.log(`migration "${it.migrationName}" was executed successfully`)
        } else if (it.status === 'Error') {
        console.error(`failed to execute migration "${it.migrationName}"`)
        }
    })

    if (error) {
        console.error('failed to migrate')
        console.error(error)
        process.exit(1)
    }

    await db.destroy()
}

migrateToLatest()

================
File: apps/api/src/features/todos/todo.controller.ts
================
import { Insertable, Kysely, Updateable } from "kysely";
import { DB, Todo } from "../../db/db-types";
import { UserDTO } from "@gefakit/shared/src/types/auth";
import { AppError } from "../../errors/app-error";
import { createTodoService } from "./todo.service";

export function createTodoController(db: Kysely<DB>) {
    const todoService = createTodoService(db);

    async function getTodos(authorId: number) {
        try {
            const result = await todoService.findAllTodosByAuthorId(authorId);
            return { todos: result };
        } catch (err) {
            if (err instanceof AppError) {
                throw err;
            }
            console.error("Unexpected error in controller.getTodos:", err);
            throw err;
        }
    }

    async function createTodo(authorId: number, todo: Insertable<Todo>) {
        try {
            const result = await todoService.createTodo(authorId, todo);
            return { todo: result };
        } catch (err) {
            if (err instanceof AppError) {
                throw err;
            }
            console.error("Unexpected error in controller.createTodo:", err);
            throw err;
        }
    }

    async function updateTodo(id: number, updateableTodo: Updateable<Todo>, userId: number) {
        try {
            const result = await todoService.updateTodo(id, updateableTodo, userId);
            return { todo: result };
        } catch (err) {
            if (err instanceof AppError) {
                throw err;
            }
            console.error("Unexpected error in controller.updateTodo:", err);
            throw err;
        }
    }

    async function deleteTodo(id: number, userId: number) {
        try {
            const result = await todoService.deleteTodo(id, userId);
            return { todo: result };
        } catch (err) {
            if (err instanceof AppError) {
                throw err;  
            }
            console.error("Unexpected error in controller.deleteTodo:", err);
            throw err;
        }
    }


    return {
        getTodos,
        createTodo,
        updateTodo,
        deleteTodo,
    };
}

================
File: apps/api/src/features/todos/todo.errors.ts
================
/**
 * This file should be defined at src/errors/index.ts
 */

import { AppError } from "../../errors/app-error";

export const todoErrors = {
  todoNotFound: () =>
    new AppError('Todo not found', 404, { code: 'TODO_NOT_FOUND' }),

  actionNotAllowed: (reason: string = 'Action not allowed') =>
    new AppError('Action not allowed', 403, { code: 'ACTION_NOT_ALLOWED', reason }),

} as const;

================
File: apps/api/src/features/todos/todo.repository.ts
================
import { Insertable, Kysely, Updateable } from "kysely";
import { AppUser, DB, Todo, UserSession } from "../../db/db-types";

export function createTodoRepository(db: Kysely<DB>) {
    return {
        async findAllTodosByAuthorId(authorId: number) {
            return db
                .selectFrom('todo')
                .selectAll()
                .where('author_id', '=', authorId)
                .orderBy('created_at', 'asc')
                .execute();
        },

        async findTodoById(id: number) {
            return db
                .selectFrom('todo')
                .selectAll()
                .where('id', '=', id)
                .executeTakeFirst();
        },

        async createTodo(authorId: number, insertableTodo: Insertable<Todo>) {
            return db
                .insertInto('todo')
                .values({ ...insertableTodo, author_id: authorId })
                .returningAll()
                .executeTakeFirstOrThrow();
        },

        async updateTodo(id: number, updateableTodo: Updateable<Todo>) {
            return db
                .updateTable('todo')
                .set(updateableTodo)
                .where('id', '=', id)
                .returningAll()
                .executeTakeFirstOrThrow()

        },

        async deleteTodo(id: number) {
            return db
                .deleteFrom('todo')
                .where('id', '=', id)
                .returningAll()
                .executeTakeFirstOrThrow();
        },
    };
}

export type TodoRepository = ReturnType<typeof createTodoRepository>;
export type FindAllTodosByAuthorIdResponse = Awaited<ReturnType<TodoRepository['findAllTodosByAuthorId']>>;

================
File: apps/api/src/features/todos/todo.routes.v1.ts
================
import { Hono } from "hono";
import { Bindings } from "../../types/hono";
import { zValidator } from "../../lib/zod-utils";
import { z } from "zod";
import { createAppError } from "../../errors";
import { createTodoController } from "./todo.controller";
import type { UserDTO, SessionDTO } from '@gefakit/shared/src/types/auth';
import { DbMiddleWareVariables } from "../../middleware/db";
import { AuthMiddleWareVariables } from "../../middleware/auth";
import { createTodoRequestBodySchema, updateTodoRequestBodySchema } from "@gefakit/shared/src/schemas/todo.schema";
import { CreateTodoResponseDTO, DeleteTodoResponseDTO, UpdateTodoResponseDTO } from "@gefakit/shared/src/types/todo";

type TodoRouteVariables = DbMiddleWareVariables & AuthMiddleWareVariables
const app = new Hono<{ Bindings: Bindings, Variables: TodoRouteVariables }>();

app.get('/', async (c) => {
    const db = c.get("db");
    const user = c.get('user');

    const todoController = createTodoController(db);
    const result = await todoController.getTodos(user.id);

    const response: { todos: any[] } = { todos: result.todos };
    return c.json(response);
});

app.post('/', zValidator('json', createTodoRequestBodySchema), async (c) => {
    const db = c.get("db");
    const user = c.get('user');
    const todoToCreate = c.req.valid('json');

    const todoController = createTodoController(db);
    const result = await todoController.createTodo(user.id, { ...todoToCreate, author_id: user.id }); 

    const response: CreateTodoResponseDTO = { createdTodo: result.todo };
    return c.json(response, 201); 
});

app.put('/:id', zValidator('json', updateTodoRequestBodySchema), async (c) => {
    const todoId = c.req.param('id');
    const db = c.get("db");
    const user = c.get('user');
    const todoToUpdate = c.req.valid('json');
    const todoController = createTodoController(db);

    const result = await todoController.updateTodo(parseInt(todoId), todoToUpdate, user.id);

    const response: UpdateTodoResponseDTO = { updatedTodo: result.todo };
    return c.json(response, 200);
});

app.delete('/:id', async (c) => {
    console.log('===================== deleteTodo =====================');
    const todoId = c.req.param('id');
    const db = c.get("db");
    const user = c.get('user');

    const todoController = createTodoController(db);
    const result = await todoController.deleteTodo(parseInt(todoId), user.id);

    const response: DeleteTodoResponseDTO = { deletedTodo: result.todo };
    return c.json(response, 200);
});

export const todoRoutesV1 = app;

================
File: apps/api/src/features/todos/todo.service.ts
================
import { Insertable, Kysely, Updateable } from "kysely";
import { DB, Todo } from "../../db/db-types";
import { createTodoRepository } from "./todo.repository";
import { createAppError } from "../../errors";

export function createTodoService(db: Kysely<DB>) {
    const repository = createTodoRepository(db);

    /**
     * Asynchronously hashes a password using bcrypt.
     *
     * @param authorId - The id of the author of the todos.
     * @returns A Promise that resolves to the todos.
     */
    async function findAllTodosByAuthorId(authorId: number) {
        return repository.findAllTodosByAuthorId(authorId);
    }

    async function createTodo(authorId: number, todo: Insertable<Todo>) {
        return repository.createTodo(authorId, todo);
    }

    async function updateTodo(id: number, updateableTodo: Updateable<Todo>, userId: number) {
        const todo = await repository.findTodoById(id);

        if (!todo) {
            throw createAppError.todos.todoNotFound();
        }

        if (todo.author_id !== userId) {
            throw createAppError.todos.actionNotAllowed();
        }

        return repository.updateTodo(id, updateableTodo);
    }

    async function deleteTodo(id: number, userId: number) {
        const todo = await repository.findTodoById(id);

        if (!todo) {
            throw createAppError.todos.todoNotFound();
        }

        if (todo.author_id !== userId) {
            throw createAppError.todos.actionNotAllowed('This is not your todo to delete!');
        }

        return repository.deleteTodo(id);
    }

    return {
        findAllTodosByAuthorId,
        createTodo,
        updateTodo,
        deleteTodo
    };
}

================
File: apps/api/src/middleware/auth.ts
================
import { getCookie } from 'hono/cookie';
import { createAppError } from '../errors';
import { createAuthController } from '../features/auth/auth.controller';
import { Bindings } from '../types/hono';
import { createMiddleware } from 'hono/factory'
import { SessionDTO, UserDTO } from '@gefakit/shared/src/types/auth';
import { DbMiddleWareVariables } from './db';

export interface AuthMiddleWareVariables extends DbMiddleWareVariables {
    user: UserDTO
    session: SessionDTO
}

// Use createMiddleware instead of MiddlewareHandler directly
export const authMiddleware = createMiddleware<{ Bindings: Bindings, Variables: AuthMiddleWareVariables }>(async (c, next) => {
    const db = c.get("db");
    const sessionToken = getCookie(c, 'gefakit-session');

    if (!sessionToken) {
        throw createAppError.auth.unauthorized('No session token provided.');
    }

    try {
        const controller = createAuthController(db);
        // Assuming getSession returns UserDTO and SessionDTO
        const { user, session } = await controller.getSession(sessionToken); 

        // These set calls should now be type-safe
        c.set('user', user);
        c.set('session', session);

        await next();
    } catch (error: any) {
        // Log the error for debugging?
        console.error("Auth Middleware Error:", error.message); 
        // Re-throw a specific unauthorized error for the client
        throw createAppError.auth.unauthorized('Invalid session token.');
    }
});

================
File: apps/web/src/components/form/components/field-info.tsx
================
import { useStore } from '@tanstack/react-form'
import { useFieldContext } from '../form-context'

export default function FieldInfo() {
    const field = useFieldContext<string>();
    const firstFormError = useStore(field.form.store, (formState) => formState.errors[0]?.[field.name]?.[0])

    const isTouched = field.state.meta.isTouched;
    const hasAttemptedSubmit = field.form.state.submissionAttempts > 0;
    const shouldShowError = (isTouched || hasAttemptedSubmit) && firstFormError

    return (
        <>
            {shouldShowError && (
                <div className="text-destructive-foreground text-sm">
                    {typeof firstFormError === 'string' ? firstFormError : firstFormError?.message}
                </div>
            )}
            {field.state.meta.isValidating ? 'Validating...' : null}
        </>
    )
}

================
File: apps/web/src/components/form/components/field-label.tsx
================
import { useStore } from '@tanstack/react-form'
import { Label } from '@/components/ui/label'
import { cn } from '@/lib/utils'
import { useFieldContext } from '../form-context'

export default function FieldLabel({ label }: { label?: string }) {
    const field = useFieldContext<string>();

    const firstFormError = useStore(field.form.store, (formState) => formState.errors[0]?.[field.name]?.[0])

    const isTouched = field.state.meta.isTouched;
    const hasAttemptedSubmit = field.form.state.submissionAttempts > 0;

    const shouldShowError = (isTouched || hasAttemptedSubmit) && firstFormError

    return (
        <Label
            className={cn(
                "mb-0.5 text-sm",
                shouldShowError && "text-destructive-foreground"
            )}
            htmlFor={field.name}
        >
            {label || field.name}
        </Label>
    )
}

================
File: apps/web/src/components/form/components/submit-button.tsx
================
import { Button } from "@/components/ui/button"
import { useFormContext } from "../form-context"

export default function SubmitButton({ label, loading, disabled }: { label: string, loading?: boolean, disabled?: boolean }) {
    const form = useFormContext()

    return (
        <form.Subscribe selector={(state) => state.isSubmitting}>
            {(isSubmitting) =>
                <Button type="submit" disabled={isSubmitting || loading || disabled}>{label}</Button>}
        </form.Subscribe>
    )
}

================
File: apps/web/src/components/form/components/submit-checkbox.tsx
================
import { Checkbox } from "@/components/ui/checkbox"
import { useFormContext } from "../form-context"

interface SubmitCheckboxProps {
    label?: string;
    loading?: boolean;
    disabled?: boolean;
    checked?: boolean;
    onCheckedChange?: (checked: boolean) => void;
}

export default function SubmitCheckbox({ label, loading, disabled, checked, onCheckedChange }: SubmitCheckboxProps) {
    const form = useFormContext()

    return (
        <form.Subscribe selector={(state) => state.isSubmitting}>
            {(isSubmitting) => (
                <div className="flex items-center space-x-2">
                    <Checkbox
                        type="submit"
                        disabled={isSubmitting || loading || disabled}
                        id="submit-checkbox"
                        checked={checked}
                        onCheckedChange={onCheckedChange}
                    />
                    {label && <label htmlFor="submit-checkbox">{label}</label>}
                </div>
            )}
        </form.Subscribe>
    )
}

================
File: apps/web/src/components/form/components/text-input.tsx
================
import { useFieldContext } from '../form-context'
import { Input } from '@/components/ui/input'
export default function TextInput(props: React.ComponentProps<typeof Input>) {
    const field = useFieldContext<string>()

    return (
        <Input
            {...props}
            id={field.name}
            name={field.name}
            type="text"
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
            onBlur={field.handleBlur}
        />
    )
}

================
File: apps/web/src/components/form/form-context.tsx
================
import { createFormHookContexts } from '@tanstack/react-form'

export const { fieldContext, useFieldContext, formContext, useFormContext } =
    createFormHookContexts()

================
File: apps/web/src/components/form/form.tsx
================
import { createFormHook } from '@tanstack/react-form'
import { fieldContext, formContext } from "./form-context";
import FieldLabel from './components/field-label';
import FieldInfo from './components/field-info';
import TextInput from './components/text-input';
import SubmitButton from './components/submit-button';
import SubmitCheckbox from './components/submit-checkbox';

/**
 * If form field components gets too many, we can use lazy loading
 */
// import { lazy } from 'react'
// const TextInput = lazy(() => import('./components/text-input'))

export const { useAppForm, withForm } = createFormHook({
  fieldComponents: {
    TextInput,
    Label: FieldLabel,
    Info: FieldInfo,
  },
  formComponents: {
    SubmitButton,
    SubmitCheckbox,
  },
  fieldContext,
  formContext,
})

================
File: apps/web/src/components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }

================
File: apps/web/src/components/ui/checkbox.tsx
================
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }

================
File: apps/web/src/components/ui/input.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }

================
File: apps/web/src/components/ui/label.tsx
================
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }

================
File: apps/web/src/features/auth/hooks/useAuth.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiGetSession, apiSignInEmail, apiSignUpEmail, apiSignOut } from '../api';
import { SignInEmailRequestBodyDTO, SignUpEmailRequestBodyDTO } from '@gefakit/shared/src/types/auth';

// Define a query key for the session data
export const sessionQueryKey = ['gefakit-session'] as const; // Use 'as const' for type safety

export function useAuth() {
    const queryClient = useQueryClient();

    // --- Session Query (from useAuthSession) ---
    const {
        data: sessionData,
        isLoading: isLoadingSession,
        isFetching: isFetchingSession,
        error: sessionError,
        refetch: refetchSession,
        isError: isSessionError
    } = useQuery({
        queryKey: sessionQueryKey,
        queryFn: apiGetSession,
        staleTime: 5 * 60 * 1000, // 5 minutes
        gcTime: 15 * 60 * 1000, // 15 minutes
        retry: 1,
        refetchOnWindowFocus: true,
        refetchInterval: false,
    });

    // --- Auth Actions (from useAuthActions) ---

    // Function to invalidate the session query cache
    const invalidateSession = () => {
        console.log('Invalidating session query:', sessionQueryKey);
        queryClient.invalidateQueries({ queryKey: sessionQueryKey });
    };

    // Sign In Email Mutation
    const {
        mutate: signInEmail,
        isPending: isSigningIn,
        error: signInError
    } = useMutation<unknown, Error, SignInEmailRequestBodyDTO>({
        mutationFn: apiSignInEmail,
        onSuccess: (data, variables, context) => {
            console.log('Sign in success:', { data, variables, context });
            invalidateSession(); // Refresh session state after sign-in
        },
        onError: (error, variables, context) => {
            console.error('Sign in error:', { error, variables, context });
        },
    });

    // Sign Up Email Mutation
    const {
        mutate: signUpEmail,
        isPending: isSigningUp,
        error: signUpError
    } = useMutation<unknown, Error, SignUpEmailRequestBodyDTO>({
        mutationFn: apiSignUpEmail,
        onSuccess: (data, variables, context) => {
            console.log('Sign up success:', { data, variables, context });
            // Currently assuming sign-up doesn't automatically log in
            // invalidateSession();
        },
        onError: (error, variables, context) => {
            console.error('Sign up error:', { error, variables, context });
        },
    });

    // Sign Out Mutation
    const {
        mutate: signOut,
        isPending: isSigningOut,
        error: signOutError
     } = useMutation({
        mutationFn: apiSignOut,
        onSettled: (data, error, variables, context) => {
            console.log('Sign out settled:', { data, error, variables, context });
            if (error) {
                console.error("Sign out API call failed, but invalidating session anyway.", error);
            }
            invalidateSession(); // Refresh session state after sign-out attempt
        }
    });

    // Social Sign In
    const signInSocial = async (provider: 'github' /* | other providers */) => {
        console.log(`Initiating social sign in with ${provider}`);
        // Adjust the URL to your backend endpoint
        window.location.href = `http://localhost:8787/api/v1/auth/social/${provider}/redirect`;
    };

    // --- Combined Return Object ---
    return {
        // Session state and methods
        session: sessionData,
        isLoadingSession,
        isFetchingSession,
        sessionError,
        isSessionError,
        refetchSession,
        isAuthenticated: !!sessionData,

        // Auth actions
        signInEmail,
        signUpEmail,
        signOut,
        signInSocial,

        // Action states
        isSigningIn,
        isSigningUp,
        isSigningOut,

        // Action errors
        signInError,
        signUpError,
        signOutError,
    };
}

================
File: apps/web/src/features/todos/components/todo-view.tsx
================
import { useTodos } from "../hooks/useTodos";
import { useForm } from "@tanstack/react-form";
import type { AnyFieldApi } from '@tanstack/react-form'
import {
    TodoDTO,
    CreateTodoRequestBodyDTO,
    UpdateTodoRequestBodyDTO,
} from "@gefakit/shared/src/types/todo";
import { createTodoRequestBodySchema } from "@gefakit/shared/src/schemas/todo.schema";
import { useAppForm } from "@/components/form/form";

function FieldInfo({ field }: { field: AnyFieldApi }) {
    return (
        <>
            {field.state.meta.isTouched && field.state.meta.errors.length ? (
                <em style={{ color: 'red', marginLeft: '5px' }}>{field.state.meta.errors.join(',')}</em>
            ) : null}
            {field.state.meta.isValidating ? 'Validating...' : null}
        </>
    )
}

export function TodoView() {
    // Destructure the values from the useTodos hook
    const {
        todos,
        isLoadingTodos,
        todosError,
        createTodo,
        isCreatingTodo,
        updateTodo,
        // isUpdatingTodo, // Uncomment if you want to show loading state for updates
        deleteTodo,
        // isDeletingTodo, // Uncomment if you want to show loading state for deletes
    } = useTodos();

    // Use useForm for the new todo input
    const form = useAppForm({
        defaultValues: {
            title: "",
            description: '',
            due_date: null,
            completed: false,
        } as CreateTodoRequestBodyDTO,
        validators: {
            onBlur: createTodoRequestBodySchema,
        },
        onSubmit: async ({ value }) => {
            console.log('value ', value);
            createTodo(value);
        }
    })
    // const form = useForm({
    //     defaultValues: {
    //         title: "",
    //     },
    //     validators: {
    //         onBlur: createTodoRequestBodySchema,
    //     },
    //     onSubmit: async ({ value }) => {
    //         // Create the full DTO for creation
    //         const newTodoData: CreateTodoRequestBodyDTO = {
    //             title: value.title.trim(),
    //             description: null, // Provide default or null values
    //             due_date: null,
    //             completed: false,
    //         };
    //         createTodo(newTodoData, {
    //             onSuccess: () => {
    //                 form.reset(); // Reset form after successful creation
    //             },
    //         });
    //     },
    // });

    const handleToggleComplete = (todo: TodoDTO) => {
        // Create the full DTO for update, only changing 'completed'
        const updateData: UpdateTodoRequestBodyDTO = {
            title: todo.title,
            description: todo.description,
            due_date: todo.due_date,
            completed: !todo.completed, // Toggle the completed status
        };
        updateTodo({ id: todo.id, data: updateData });
    };

    const handleDeleteTodo = (id: number) => {
        deleteTodo(id);
    };

    if (isLoadingTodos) {
        return <div>Loading todos...</div>;
    }

    if (todosError) {
        return <div>Error loading todos: {todosError.message}</div>;
    }

    return (
        <div>
            <h2>Todos</h2>

            {/* Create Todo Form using @tanstack/react-form */}
            <form
                onSubmit={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Submitting.')
                    form.handleSubmit();
                }}
            >
                <form.AppForm>
                    <form.AppField
                        name='title'
                        children={(field) =>
                            <>
                                <field.Label label="Title" />
                                <field.TextInput />
                                <field.Info />
                            </>}
                    />
                    <form.SubmitButton label="Add Todo" loading={isCreatingTodo} />
                </form.AppForm>
            </form>

            {/* Todo List */}
            <ul>
                {todos.map((todo) => (
                    <li key={todo.id} style={{ display: 'flex', alignItems: 'center', marginBottom: '5px' }}>
                        <input
                            type="checkbox"
                            checked={todo.completed}
                            onChange={() => handleToggleComplete(todo)}
                            style={{ marginRight: '10px' }}
                        />
                        <span style={{ textDecoration: todo.completed ? 'line-through' : 'none', flexGrow: 1 }}>
                            {todo.title} {todo.description ? `(${todo.description})` : ''} {/* Optionally display description */}
                        </span>
                        {/* Optionally display due date */}
                        {todo.due_date && <span style={{ fontStyle: 'italic', marginRight: '10px' }}>Due: {new Date(todo.due_date).toLocaleDateString()}</span>}
                        <button onClick={() => handleDeleteTodo(todo.id)} style={{ marginLeft: '10px' }}>
                            {/* Consider adding disabled state based on isDeletingTodo if needed */}
                            Delete
                        </button>
                    </li>
                ))}
            </ul>
            {todos.length === 0 && !isLoadingTodos && <p>No todos yet!</p>}
        </div>
    );
}

================
File: apps/web/src/features/todos/hooks/useTodos.ts
================
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiGetTodos, apiCreateTodo, apiUpdateTodo, apiDeleteTodo } from '../api';
import { TodoDTO, UpdateTodoRequestBodyDTO } from '@gefakit/shared/src/types/todo';

export function useTodos() {
    const queryClient = useQueryClient();

    // Fetch Todos Query
    const { data: todosData, isLoading: isLoadingTodos, error: todosError } = useQuery<{ todos: TodoDTO[] }, Error >({
        queryKey: ['todos'],
        queryFn: apiGetTodos,
        // staleTime: 5 * 60 * 1000, // Optional: Configure data freshness
    });

    // Create Todo Mutation
    const { mutate: createTodo, isPending: isCreatingTodo } = useMutation({
        mutationFn: apiCreateTodo,
        onMutate: async (newTodo) => {
            // Cancel any outgoing refetches (so they don't overwrite our optimistic update)
            await queryClient.cancelQueries({ queryKey: ['todos'] });

            // Snapshot the previous value
            const previousTodos = queryClient.getQueryData< { todos: TodoDTO[] } >(['todos']);

            // Optimistically update to the new value
            if (previousTodos) {
                queryClient.setQueryData< { todos: TodoDTO[] } >(['todos'], {
                    todos: [
                        ...previousTodos.todos,
                        // Add a temporary ID for the optimistic update
                        // The actual ID will come from the server response
                        { ...newTodo, id: Date.now(), completed: false, author_id: -1 /* Placeholder */ },
                    ],
                });
            }

            // Return a context object with the snapshotted value
            return { previousTodos };
        },
        // If the mutation fails, use the context returned from onMutate to roll back
        onError: (err, newTodo, context) => {
            if (context?.previousTodos) {
                queryClient.setQueryData(['todos'], context.previousTodos);
            }
            console.error("Error creating todo:", err);
            // Optionally: show a notification to the user
        },
        // Always refetch after error or success:
        onSettled: () => {
            queryClient.invalidateQueries({ queryKey: ['todos'] });
        },
    });

    // Update Todo Mutation
    const { mutate: updateTodo, isPending: isUpdatingTodo } = useMutation({
        mutationFn: ({ id, data }: { id: number; data: UpdateTodoRequestBodyDTO }) => apiUpdateTodo(id, data),
        onMutate: async ({ id, data: updatedTodoData }) => {
            await queryClient.cancelQueries({ queryKey: ['todos'] });
            const previousTodos = queryClient.getQueryData< { todos: TodoDTO[] } >(['todos']);

            if (previousTodos) {
                queryClient.setQueryData< { todos: TodoDTO[] } >(['todos'], {
                    todos: previousTodos.todos.map((todo) =>
                        todo.id === id ? { ...todo, ...updatedTodoData } : todo
                    ),
                });
            }
            return { previousTodos };
        },
        onError: (err, variables, context) => {
            if (context?.previousTodos) {
                queryClient.setQueryData(['todos'], context.previousTodos);
            }
            console.error("Error updating todo:", err);
        },
        onSettled: () => {
            queryClient.invalidateQueries({ queryKey: ['todos'] });
        },
    });

    // Delete Todo Mutation
    const { mutate: deleteTodo, isPending: isDeletingTodo } = useMutation({
        mutationFn: apiDeleteTodo,
        onMutate: async (idToDelete) => {
            await queryClient.cancelQueries({ queryKey: ['todos'] });
            const previousTodos = queryClient.getQueryData< { todos: TodoDTO[] } >(['todos']);

            if (previousTodos) {
                queryClient.setQueryData< { todos: TodoDTO[] } >(['todos'], {
                    todos: previousTodos.todos.filter((todo) => todo.id !== idToDelete),
                });
            }
            return { previousTodos };
        },
        onError: (err, idToDelete, context) => {
            if (context?.previousTodos) {
                queryClient.setQueryData(['todos'], context.previousTodos);
            }
            console.error("Error deleting todo:", err);
        },
        onSettled: () => {
            queryClient.invalidateQueries({ queryKey: ['todos'] });
        },
    });

    return {
        todos: todosData?.todos ?? [], // Provide a default empty array
        isLoadingTodos,
        todosError,
        createTodo,
        isCreatingTodo,
        updateTodo,
        isUpdatingTodo,
        deleteTodo,
        isDeletingTodo,
    };
}

================
File: apps/web/src/features/todos/api.ts
================
import { CreateTodoRequestBodyDTO, TodoDTO, UpdateTodoRequestBodyDTO } from "@gefakit/shared/src/types/todo";

const API_BASE_URL = 'http://localhost:8787/api/v1/todos';

export const apiGetTodos = async (): Promise<{ todos: TodoDTO[] }> => {
  try {
    const response = await fetch(`${API_BASE_URL}`, {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
      },
      credentials: 'include',
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch todos: Server responded with ${response.status}`);
    }

    const data = await response.json();
    return data as { todos: TodoDTO[] };
  } catch (error) {
    console.error("Error during apiGetTodos fetch:", error);
    throw error;
  }
};

export const apiCreateTodo = async (todoData: CreateTodoRequestBodyDTO): Promise<{ createdTodo: TodoDTO }> => {
  try {
    const response = await fetch(`${API_BASE_URL}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(todoData),
      credentials: 'include',
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ message: 'Failed to create todo' }));
      throw new Error(errorData.message || 'Todo creation failed');
    }
    return response.json();
  } catch (error) {
    console.error("Error during apiCreateTodo fetch:", error);
    throw error;
  }
};

export const apiUpdateTodo = async (id: number, todoData: UpdateTodoRequestBodyDTO): Promise<{ updatedTodo: TodoDTO }> => {
  try {
    const response = await fetch(`${API_BASE_URL}/${id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(todoData),
      credentials: 'include',
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ message: 'Failed to update todo' }));
      throw new Error(errorData.message || 'Todo update failed');
    }
    return response.json();
  } catch (error) {
    console.error("Error during apiUpdateTodo fetch:", error);
    throw error;
  }
};

// Note: The backend route for deleting todos (DELETE /:id) might not be implemented yet.
export const apiDeleteTodo = async (id: number): Promise<{ deletedTodo: TodoDTO }> => {
 try {
    const response = await fetch(`${API_BASE_URL}/${id}`, {
      method: 'DELETE',
      credentials: 'include',
    });

     if (!response.ok) {
        // Handle potential errors, e.g., todo not found (404) or server error (500)
        const errorData = await response.json().catch(() => ({ message: 'Failed to delete todo' }));
        // Check for 404 specifically if needed, or just throw a general error
        throw new Error(errorData.message || `Todo deletion failed with status ${response.status}`);
    }

     return response.json();
  } catch (error) {
    console.error("Error during apiDeleteTodo fetch:", error);
    throw error;
  }
};

================
File: apps/web/src/lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: apps/web/components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/index.css",
    "baseColor": "stone",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

================
File: packages/shared/src/schemas/todo.schema.ts
================
import { z } from 'zod';

export const todoSchema = z.object({
  id: z.number().int().positive(),
  title: z.string(),
  description: z.string().nullable(),
  due_date: z.date().nullable(),
  completed: z.boolean(),
  author_id: z.number().int().positive(),
  created_at: z.date(),
});


export const creatableTodoSchema = todoSchema
  .omit({ id: true, author_id: true, created_at: true })
  .extend({
    title: z.string().min(5, 'Title must be at least 5 characters long.'),
    description: z.string().max(250, 'Description must be less than 250 characters.').nullable(),
    due_date: z.date().nullable().refine((date) => date === null || date > new Date(), {
      message: 'Due date cannot be in the past.',
    }),
  });

export const updatableTodoSchema = creatableTodoSchema.partial()

export const createTodoRequestBodySchema = creatableTodoSchema;
export const createTodoResponseSchema = todoSchema;

export const updateTodoRequestBodySchema = updatableTodoSchema;
export const updateTodoResponseSchema = todoSchema;

export const deleteTodoResponseSchema = z.object({
  deletedTodo: todoSchema,
});

================
File: packages/shared/src/types/todo.ts
================
import { z } from "zod";
import { createTodoRequestBodySchema, todoSchema, updateTodoRequestBodySchema } from "../schemas/todo.schema";

export type TodoDTO = z.infer<typeof todoSchema>;

export type CreateTodoRequestBodyDTO = z.infer<typeof createTodoRequestBodySchema>;
export type CreateTodoResponseDTO = { createdTodo: TodoDTO };

export type UpdateTodoRequestBodyDTO = z.infer<typeof updateTodoRequestBodySchema>;
export type UpdateTodoResponseDTO = { updatedTodo: TodoDTO };

export type DeleteTodoResponseDTO = { deletedTodo: TodoDTO };

================
File: .repomixignore
================
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

apps/api/worker-configuration.d.ts
apps/web/worker-configuration.d.ts
*.svg

================
File: repomix.config.json
================
{
  "output": {
    "filePath": "repomix-output.txt",
    "style": "plain",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 10,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}

================
File: apps/api/public/index.html
================
<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Hello, World!</title>
	</head>
	<body>
		<h1 id="heading"></h1>
		<script>
			fetch('/message')
				.then((resp) => resp.text())
				.then((text) => {
					const h1 = document.getElementById('heading');
					h1.textContent = text;
				});
		</script>
	</body>
</html>

================
File: apps/api/src/db/migrations/0002_user.ts
================
import { Kysely, sql } from 'kysely'

export async function up(db: Kysely<any>): Promise<void> {
  // Alter the existing app_user table to add new columns
  await db.schema
    .alterTable('app_user')
    .addColumn('email', 'text', (col) => col.notNull().unique())
    .addColumn('password_hash', 'text', (col) => col.notNull())
    .addColumn('recovery_code', 'bytea')
    .addColumn('created_at', 'timestamptz', (col) => 
      col.defaultTo(sql`now()`).notNull())
    .execute()

  // No need to recreate user_session table as it already exists from the first migration
}

export async function down(db: Kysely<any>): Promise<void> {
  // Remove the columns added in this migration
  await db.schema
    .alterTable('app_user')
    .dropColumn('email')
    .dropColumn('password_hash')
    .dropColumn('recovery_code')
    .dropColumn('created_at')
    .execute()
}

================
File: apps/api/src/db/seeds/first.ts
================
// seed.ts

import { Kysely } from 'kysely'
import { DB } from '../db-types'
import { config } from 'dotenv'
import { NeonDialect } from 'kysely-neon'

// Choose a config file based on NODE_ENV
const env = process.env.NODE_ENV || 'development'
const envFile =
  env === 'production'
    ? '.dev.vars.production'
    : env === 'staging'
    ? '.dev.vars.staging'
    : '.dev.vars'

// Load environment variables from the appropriate file
config({ path: envFile })

async function seed() {
  const db = new Kysely<DB>({
    dialect: new NeonDialect({
      connectionString: process.env.DATABASE_URL,
    }),
  })

  // Add 3 random people
  const person1 = await db
    .insertInto('person')
    .values({
      first_name: 'John',
      last_name: 'Doe',
      gender: 'male',
    })
    .returning('id')
    .executeTakeFirstOrThrow()

  const person2 = await db
    .insertInto('person')
    .values({
      first_name: 'Jane',
      last_name: 'Smith',
      gender: 'female',
    })
    .returning('id')
    .executeTakeFirstOrThrow()

  const person3 = await db
    .insertInto('person')
    .values({
      first_name: 'Alex',
      last_name: 'Johnson',
      gender: 'non-binary',
    })
    .returning('id')
    .executeTakeFirstOrThrow()

  // Add 5 pets
  await db
    .insertInto('pet')
    .values([
      {
        name: 'Fluffy',
        owner_id: person1.id,
        species: 'cat',
      },
      {
        name: 'Rex',
        owner_id: person1.id,
        species: 'dog',
      },
      {
        name: 'Whiskers',
        owner_id: person2.id,
        species: 'cat',
      },
      {
        name: 'Buddy',
        owner_id: person3.id,
        species: 'dog',
      },
      {
        name: 'Goldie',
        owner_id: person3.id,
        species: 'fish',
      },
    ])
    .execute()

  console.log('Database seeded successfully!')
  await db.destroy()
}

seed().catch((error) => {
  console.error('Failed to seed database:', error)
  process.exit(1)
})

================
File: apps/api/src/db/migrate.ts
================
import * as path from 'path'
import { promises as fs } from 'fs'
import {
  Kysely,
  Migrator,
  FileMigrationProvider,
} from 'kysely'
import { NeonDialect } from 'kysely-neon'
import { config } from 'dotenv'

// Choose a config file based on NODE_ENV
const env = process.env.NODE_ENV || 'development'
const envFile =
  env === 'production'
    ? '.dev.vars.production'
    : env === 'staging'
    ? '.dev.vars.staging'
    : '.dev.vars'

// Load environment variables from the appropriate file
config({ path: envFile })

async function migrateToLatest() {

    console.log('process.env.DATABASE_URL: ', process.env.DATABASE_URL)

    const db = new Kysely<any>({
        dialect: new NeonDialect({
            connectionString: process.env.DATABASE_URL,
        }),
    })

    const migrator = new Migrator({
        db,
        provider: new FileMigrationProvider({
        fs,
        path,
        // This needs to be an absolute path.
        migrationFolder: path.join(__dirname, 'migrations'),
        }),
    })

    const { error, results } = await migrator.migrateToLatest()

    results?.forEach((it) => {
        if (it.status === 'Success') {
        console.log(`migration "${it.migrationName}" was executed successfully`)
        } else if (it.status === 'Error') {
        console.error(`failed to execute migration "${it.migrationName}"`)
        }
    })

    if (error) {
        console.error('failed to migrate')
        console.error(error)
        process.exit(1)
    }

    await db.destroy()
}

migrateToLatest()

================
File: apps/api/src/errors/app-error.ts
================
// src/lib/app-error.ts
export class AppError extends Error {
    readonly status: number;
    readonly details?: Record<string, any>;
  
    constructor(message: string, status = 400, details?: Record<string, any>) {
      super(message);
      // Set the prototype explicitly for correct instanceof checks
      Object.setPrototypeOf(this, new.target.prototype);
  
      this.name = 'AppError'; // Consistent name for easy identification
      this.status = status;
      this.details = details;
    }
  }

================
File: apps/api/src/errors/index.ts
================
/**
 * Import all feature-specific error creators here.
 */

import { authErrors } from '../features/auth/auth.errors';
import { todoErrors } from '../features/todos/todo.errors';

/**
 * Central object for creating application-specific errors.
 * Usage: `throw createAppError.auth.invalidCredentials();`
 * `throw createAppError.todos.notFound('123');`
 */
export const createAppError = {
  auth: authErrors,
  todos: todoErrors,
  // users: userErrorCreators,
  // Add other features here...
};

================
File: apps/api/src/features/auth/auth.controller.ts
================
import { createAuthService } from "./auth.service";
import { Kysely } from "kysely";
import { DB } from "../../db/db-types";
import { UserDTO } from "@gefakit/shared/src/types/auth";
import { AppError } from "../../errors/app-error";

export function createAuthController(db: Kysely<DB>) {
    const authService = createAuthService(db);

    async function getSession(token: string) {
        return authService.getCurrentSession(token);
    }

    async function signIn(data: { email: string; password: string }) {
        try {
            const result = await authService.signInWithEmail(data);
            return { user: result.user, sessionToken: result.sessionToken };
        } catch (err) {
            if (err instanceof AppError) {
                throw err;
            }
            console.error("Unexpected error in controller.signIn:", err);
            throw err;
        }
    }

    async function signUp(data: { email: string; password: string; username: string }): Promise<{ user: UserDTO }> {
        try {
            const user = await authService.signUpWithEmail(data);
            return { user };
        } catch (err) {
            if (err instanceof AppError) {
                throw err;
            }
            console.error("Unexpected error in controller.signUp:", err);
            throw err;
        }
    }

    async function signOut(sessionToken: string) {
        try {
            await authService.invalidateSession(sessionToken);
        } catch (err) {
            console.error("Unexpected error in controller.signOut:", err);
            throw err;
        }
    }

    return {
        signIn,
        signUp,
        signOut,
        getSession
    };
}

================
File: apps/api/src/features/auth/auth.errors.ts
================
/**
 * This file should be defined at src/errors/index.ts
 */

import { AppError } from "../../errors/app-error";

export const authErrors = {
  invalidCredentials: () =>
    new AppError('Invalid credentials provided', 401, { code: 'AUTH_INVALID_CREDENTIALS' }),

  unauthorized: (reason: string = 'No session found') =>
    new AppError('Unauthorized access', 401, { code: 'AUTH_UNAUTHORIZED', reason }),

  tokenExpired: () =>
    new AppError('Session token has expired', 401, { code: 'AUTH_TOKEN_EXPIRED' }),

  weakPassword: (reason: string) =>
    new AppError(`Password is too weak: ${reason}`, 400, { code: 'AUTH_WEAK_PASSWORD', reason }),

  userCreationFailed: (details?: Record<string, any>) =>
    new AppError('Failed to create user account', 500, { code: 'AUTH_USER_CREATION_FAILED', ...details })
} as const;

================
File: apps/api/src/features/auth/auth.repository.ts
================
import { Insertable, Kysely } from "kysely";
import { AppUser, DB, UserSession } from "../../db/db-types";

export function createAuthRepository(db: Kysely<DB>) {
    return {
        async findUserWithPasswordByEmail(data: { email: string }) {
            return db
                .selectFrom('app_user')
                .where('email', '=', data.email)
                .select(['id', 'email', 'username', 'password_hash', 'created_at'])
                .executeTakeFirst();
        },

        async createUser(insertableUser: Insertable<AppUser>) {
            return db
                .insertInto('app_user')
                .values(insertableUser)
                .returning(['id', 'email', 'username', 'created_at'])
                .executeTakeFirst();
        },

        async createSession(data: Insertable<UserSession>) {
            return db
                .insertInto('user_session')
                .values(data)
                .returning(['id', 'user_id', 'expires_at'])
                .executeTakeFirst();
        },

        async findSessionWithUser(data: { sessionId: string }) {
            return db
                .selectFrom('user_session')
                .innerJoin('app_user', 'app_user.id', 'user_session.user_id')
                .select([
                    'user_session.id',
                    'user_session.user_id',
                    'user_session.expires_at',
                    'app_user.id as user_id',
                    'app_user.email',
                    'app_user.username',
                    'app_user.created_at'
                ])
                .where('user_session.id', '=', data.sessionId)
                .executeTakeFirst();
        },

        async updateSessionExpiry(data: { sessionId: string; expiresAt: Date }) {
            return db
                .updateTable('user_session')
                .set({ expires_at: data.expiresAt })
                .where('id', '=', data.sessionId)
                .execute();
        },

        async deleteSession(data: { sessionId: string }) {
            return db
                .deleteFrom('user_session')
                .where('id', '=', data.sessionId)
                .execute();
        },

        async deleteAllUserSessions(data: { userId: number }) {
            return db
                .deleteFrom('user_session')
                .where('user_id', '=', data.userId)
                .execute();
        }
    };
}

================
File: apps/api/src/features/auth/auth.routes.v1.ts
================
import { Hono } from "hono";
import { createAuthController } from "./auth.controller";
import { Bindings } from "../../types/hono";
import { getCookie, setCookie, deleteCookie } from "hono/cookie";
import { signUpEmailRequestBodySchema, signInEmailRequestBodySchema } from "@gefakit/shared/src/schemas/auth.schema";
import { zValidator } from "../../lib/zod-utils";
import { GetSessionResponseDTO, SignInEmailResponseDTO, SignOutResponseDTO, SignUpEmailResponseDTO } from "@gefakit/shared/src/types/auth";
import { createAppError } from "../../errors";
import { DbMiddleWareVariables } from "../../middleware/db";

type AuthRouteVariables = DbMiddleWareVariables
const app = new Hono<{ Bindings: Bindings, Variables: AuthRouteVariables }>();

app.get('/session', async (c) => {
    const db = c.get("db");
    const sessionToken = getCookie(c, 'gefakit-session');

    if (!sessionToken) {
        throw createAppError.auth.unauthorized();
    }

    const controller = createAuthController(db);
    const result = await controller.getSession(sessionToken);

    const response: GetSessionResponseDTO = { session: result.session, user: result.user };
    return c.json(response);
});

app.post('/sign-in/email', zValidator('json', signInEmailRequestBodySchema), async (c) => {
    const db = c.get("db");
    const body = c.req.valid('json');

    const controller = createAuthController(db);
    const result = await controller.signIn(body);
    
    setCookie(c, 'gefakit-session', result.sessionToken, {
        httpOnly: true,
        secure: true,
        sameSite: 'Lax'
    });

    const response: SignInEmailResponseDTO = { user: result.user };
    return c.json(response);
});

app.post('/sign-up/email', zValidator('json', signUpEmailRequestBodySchema), async (c) => {
    const db = c.get("db");
    const body = c.req.valid('json');

    const controller = createAuthController(db);
    const { user } = await controller.signUp(body);

    const response: SignUpEmailResponseDTO = { user };
    return c.json(response);
});

app.post('/sign-out', async (c) => {
    const db = c.get("db");
    const sessionToken = getCookie(c, 'gefakit-session');
    const controller = createAuthController(db);

    if (sessionToken) {
        await controller.signOut(sessionToken);
        deleteCookie(c, 'gefakit-session');
    }

    const response: SignOutResponseDTO = { message: 'Signed out successfully' };
    return c.json(response);
});

export const authRoutesV1 = app;

================
File: apps/api/src/features/auth/auth.service.ts
================
import { encodeHexLowerCase } from "@oslojs/encoding";
import { Kysely } from "kysely";
import { DB } from "../../db/db-types";
import { createAuthRepository } from "./auth.repository";
import { sha256 } from "@oslojs/crypto/sha2";
import { encodeBase32LowerCaseNoPadding } from "@oslojs/encoding";
import bcrypt from 'bcryptjs';
import { SessionDTO, UserDTO } from "@gefakit/shared";
import { isMyPasswordPwned } from "./pwned";
import { createAppError } from "../../errors";

export function createAuthService(db: Kysely<DB>) {
    const repository = createAuthRepository(db);
    const SESSION_DURATION = 30 * 24 * 60 * 60 * 1000;
    const SESSION_RENEWAL_THRESHOLD = 15 * 24 * 60 * 60 * 1000;

    /**
     * Asynchronously hashes a password using bcrypt.
     *
     * @param password - The plaintext password to hash.
     * @param saltRounds - The cost factor (number of salt rounds) for hashing (default is 12).
     * @returns A Promise that resolves to the hashed password.
     */
    async function hashPassword(password: string, saltRounds: number = 12) {
        const salt = await bcrypt.genSalt(saltRounds);
        const hash = await bcrypt.hash(password, salt);
        return hash;
    }

    /**
     * Asynchronously verifies a password against a given hash.
     *
     * @param password - The plaintext password to verify.
     * @param hash - The hashed password to compare against.
     * @returns A Promise that resolves to true if the password matches the hash, false otherwise.
     */
    async function verifyPassword(password: string, hash: string) {
        const result = await bcrypt.compare(password, hash);
        return result;
    }

    /**
     * Generates a cryptographically secure random session token.
     * 
     * @returns A base32 encoded string representing the session token.
     */
    function generateSessionToken(): string {
        const bytes = new Uint8Array(20);
        crypto.getRandomValues(bytes);
        return encodeBase32LowerCaseNoPadding(bytes);
    }

    /**
     * Generates a session ID by hashing the provided token.
     * 
     * @param token - The session token to hash.
     * @returns A hex-encoded string representing the session ID.
     */
    function generateSessionId(token: string): string {
        return encodeHexLowerCase(sha256(new TextEncoder().encode(token)));
    }

    /**
     * Creates a new session for the specified user.
     * 
     * @param userId - The ID of the user to create a session for.
     * @returns A Promise that resolves to an object containing the session and token.
     */
    async function createSession(userId: number): Promise<{ session: SessionDTO; token: string }> {
        const token = generateSessionToken();
        const sessionId = generateSessionId(token);
        
        const session = await repository.createSession({
            id: sessionId,
            user_id: userId,
            expires_at: new Date(Date.now() + SESSION_DURATION)
        })

        if (!session) {
            throw new Error('Failed to create session');
        }

        return { 
            session: {
                id: session.id,
                user_id: session.user_id,
                expires_at: session.expires_at,
            }, 
            token 
        };
    }

    /**
     * Validates a session token and retrieves the associated session and user.
     * 
     * @param token - The session token to validate.
     * @returns A Promise that resolves to an object containing the session and user, or null values if invalid.
     */
    async function validateSession(token: string) {
        const sessionId = generateSessionId(token);
        const result = await repository.findSessionWithUser({ sessionId });

        console.log('validating session: ', {sessionId, result})

        if (!result) {
            return { session: null, user: null };
        }

        const session: SessionDTO = {
            id: result.id,
            user_id: result.user_id,
            expires_at: result.expires_at
        };

        // Handle expired session
        if (Date.now() >= session.expires_at.getTime()) {
            await repository.deleteSession({ sessionId });
            return { session: null, user: null };
        }

        // Extend session if approaching expiration
        if (Date.now() >= session.expires_at.getTime() - SESSION_RENEWAL_THRESHOLD) {
            const newExpiryDate = new Date(Date.now() + SESSION_DURATION);
            await repository.updateSessionExpiry({ 
                sessionId: session.id, 
                expiresAt: newExpiryDate 
            });
            session.expires_at = newExpiryDate;
        }

        const user: UserDTO = {
            id: result.user_id,
            email: result.email,
            username: result.username,
            created_at: result.created_at
        };

        return { session, user };
    }

    /**
     * Authenticates a user with email and password, creating a new session if successful.
     * 
     * @param email - The user's email address.
     * @param password - The user's password.
     * @returns A Promise that resolves to an object containing the user and session token.
     */
    async function signInWithEmail(data: { email: string; password: string }) {
        const user = await repository.findUserWithPasswordByEmail({ email: data.email });
        if (!user) {
            throw createAppError.auth.invalidCredentials();
        }

        const isValidPassword = await verifyPassword(data.password, user.password_hash);
        if (!isValidPassword) {
            throw createAppError.auth.invalidCredentials();
        }

        const { token } = await createSession(user.id);

        const { password_hash, ...userWithoutPassword } = user;
        return {
            user: userWithoutPassword,
            sessionToken: token
        };
    }

    /**
     * Creates a new user account with the provided email, password, and username.
     * 
     * @param data - The user creation parameters
     * @param data.email - The email address for the new user
     * @param data.password - The password for the new user
     * @param data.username - The username for the new user
     * @returns A Promise that resolves to the created user object.
     */
    async function signUpWithEmail(data: { email: string; password: string; username: string }): Promise<UserDTO> {
        const existingUser = await repository.findUserWithPasswordByEmail({email: data.email});
        if (existingUser) {
          throw createAppError.auth.invalidCredentials();
        }
      
        const passwordHash = await hashPassword(data.password);

        if (data.password.length < 8 || data.password.length > 255) {
            throw createAppError.auth.weakPassword('Password must be between 8 and 255 characters long.');
        }

        const isPwned = await isMyPasswordPwned(data.password);
        console.log('isPwned: ', data.password, isPwned)
        // Check if password is strong
        if (isPwned) {
            throw createAppError.auth.weakPassword('Password was found in a data breach.');
        }

        const user = await repository.createUser({
          email: data.email,
          username: data.username,
          password_hash: passwordHash
        });

      
        if (!user) {
          throw createAppError.auth.userCreationFailed();
        }
      
        return user;
    }

    /**
     * Retrieves the current session and associated user for a given session token.
     * 
     * @param token - The session token to validate.
     * @returns A Promise that resolves to an object containing the session and user.
     */
    async function getCurrentSession(token: string): Promise<{ session: any; user: any }> {
        return await validateSession(token);
    }

    /**
     * Invalidates a session by deleting it from the database.
     * 
     * @param token - The session token to invalidate.
     * @returns A Promise that resolves when the session has been invalidated.
     */
    async function invalidateSession(token: string): Promise<void> {
        const sessionId = generateSessionId(token);
        console.log('invalidating sessionId: ', {sessionId})
        await repository.deleteSession({ sessionId });
    }

    /**
     * Invalidates all sessions for a specific user.
     * 
     * @param userId - The ID of the user whose sessions should be invalidated.
     * @returns A Promise that resolves when all sessions have been invalidated.
     */
    async function invalidateAllSessions(userId: number): Promise<void> {
        await repository.deleteAllUserSessions({ userId });
    }

    return {
        signInWithEmail,
        signUpWithEmail,
        validateSession,
        getCurrentSession,
        invalidateSession,
        invalidateAllSessions,
        generateSessionToken,
        generateSessionId,
        createSession,
        hashPassword,
        verifyPassword
    };
}

================
File: apps/api/src/features/auth/pwned.ts
================
export async function isMyPasswordPwned(password: string): Promise<boolean> {
    try {
        // Encode the password as a Uint8Array.
        const encoder = new TextEncoder();
        const data = encoder.encode(password);
      
        // Generate the SHA1 hash using Web Crypto API.
        const hashBuffer = await crypto.subtle.digest('SHA-1', data);
      
        // Convert the ArrayBuffer to a hexadecimal string.
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const sha1Hash = hashArray
          .map(b => b.toString(16).padStart(2, '0'))
          .join('')
          .toUpperCase();
      
        // Split the hash into the first 5 characters (prefix) and the rest (suffix).
        const prefix = sha1Hash.slice(0, 5);
        const suffix = sha1Hash.slice(5);

        // Request the API with the hash prefix.
        const url = `https://api.pwnedpasswords.com/range/${prefix}`;
        const response = await fetch(url);
        if (!response.ok) {
            return false;
        }
      
        // The API response is plain text, with each line in the format "HASH_SUFFIX:COUNT".
        const body = await response.text();
        const lines = body.split('\n');
      
        // Check if any of the returned suffixes match the remainder of our hash.
        for (const line of lines) {
          const [returnedSuffix] = line.split(':');
          if (returnedSuffix.trim() === suffix) {
            // Password found as compromised.
            return true;
          }
        }
      
        // Password not found.
        return false;
    } catch (error) {
        // If any error occurs (network issues, API problems, etc.), consider the password safe
        return false;
    }
}

================
File: apps/api/src/lib/zod-utils.ts
================
/**
 * Wrapper for zValidator that throws a HTTPException if the validation fails.
 */
import { ZodSchema } from 'zod'
import type { ValidationTargets } from 'hono'
import { zValidator as zv } from '@hono/zod-validator'
import { HTTPException } from "hono/http-exception";

export const zValidator = <T extends ZodSchema, Target extends keyof ValidationTargets>(
  target: Target,
  schema: T
) =>
  zv(target, schema, (result, c) => {
    if (!result.success) {
      throw new HTTPException(400, { cause: result.error })
    }
  })

================
File: apps/api/.gitignore
================
# prod
dist/

# dev
.yarn/
!.yarn/releases
.vscode/*
!.vscode/launch.json
!.vscode/*.code-snippets
.idea/workspace.xml
.idea/usage.statistics.xml
.idea/shelf

# deps
node_modules/
.wrangler

# env
.env
.env.production
.dev.vars
.dev.vars.*

# logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# misc
.DS_Store

================
File: apps/api/README.md
================
```
npm install
npm run dev
```

```
npm run deploy
```

================
File: apps/api/tsconfig.json
================
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "skipLibCheck": true,
    "lib": [
      "ESNext"
    ],
    "types": [
      "@cloudflare/workers-types/2023-07-01",
      "node"
    ],
    "jsx": "react-jsx",
    "jsxImportSource": "hono/jsx"
  },
}

================
File: apps/web/src/features/auth/hooks/useAuthActions.ts
================
// /features/auth/hooks/useAuthActions.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { apiSignInEmail, apiSignUpEmail, apiSignOut } from '../api';
import { sessionQueryKey } from './useAuthSession';

export function useAuthActions() {
  const queryClient = useQueryClient();

  // Function to invalidate the session query cache
  const invalidateSession = () => {
    console.log('Invalidating session query:', sessionQueryKey);
    queryClient.invalidateQueries({ queryKey: sessionQueryKey });
  };

  const signInEmailMutation = useMutation({
    mutationFn: apiSignInEmail,
    onSuccess: (data, variables, context) => {
      console.log('Sign in success:', { data, variables, context });
      invalidateSession(); // Refresh session state after sign-in
    },
    onError: (error, variables, context) => {
      console.error('Sign in error:', { error, variables, context });
    },
  });

  const signUpEmailMutation = useMutation({
    mutationFn: apiSignUpEmail,
    onSuccess: (data, variables, context) => {
      console.log('Sign up success:', { data, variables, context });
      // Decide if sign-up should automatically log the user in.
      // If yes, invalidate the session. If no, maybe prompt to log in.
      // Assuming sign-up *doesn't* log in automatically here.
      // invalidateSession();
    },
    onError: (error, variables, context) => {
      console.error('Sign up error:', { error, variables, context });
    },
  });

  const signOutMutation = useMutation({
    mutationFn: apiSignOut,
    // Use onSettled to ensure invalidation happens even if the sign-out API call
    // itself fails (e.g., network error), as the user intent is to be signed out.
    onSettled: (data, error, variables, context) => {
       console.log('Sign out settled:', { data, error, variables, context });
       if (error) {
         console.error("Sign out API call failed, but invalidating session anyway.", error);
       }
       invalidateSession(); // Refresh session state after sign-out attempt
    }
    // Alternatively, use onSuccess if you only want to invalidate on a successful API response:
    // onSuccess: (data, variables, context) => {
    //   console.log('Sign out success:', { data, variables, context });
    //   invalidateSession();
    // },
    // onError: (error, variables, context) => {
    //   console.error('Sign out error:', { error, variables, context });
    //   // Still might want to invalidate or clear session data locally on error
    //   invalidateSession();
    // }
  });

  // Handle social sign-in (still needs specific implementation)
  // This likely involves window redirects or popups, not a standard mutation.
  // Invalidation would happen when the user returns to the app after social auth.
  const signInSocial = async (provider: 'github' /* | other providers */) => {
    console.log(`Initiating social sign in with ${provider}`);
    // Construct the correct URL for your backend social auth initiation
    // Example: GET /api/v1/auth/social/github/redirect
    // This backend endpoint would handle the redirect to GitHub.
    // After GitHub redirects back to your app (callback URL),
    // your backend handles the code exchange, creates a session,
    // and then redirects the user back to the frontend.
    // The useSession hook should then pick up the new session on load.
    window.location.href = `http://localhost:8787/api/v1/auth/social/${provider}/redirect`; // Adjust URL/method as needed
  };

  return {
    signInEmail: signInEmailMutation.mutate,
    signUpEmail: signUpEmailMutation.mutate,
    signOut: signOutMutation.mutate,
    signInSocial,

    isSigningIn: signInEmailMutation.isPending,
    isSigningUp: signUpEmailMutation.isPending,
    isSigningOut: signOutMutation.isPending,

    signInError: signInEmailMutation.error,
    signUpError: signUpEmailMutation.error,
    signOutError: signOutMutation.error,
  };
}

================
File: apps/web/src/features/auth/hooks/useAuthSession.ts
================
// /features/auth/hooks/useSession.ts
import { useQuery } from '@tanstack/react-query';
import { apiGetSession } from '../api';

// Define a query key for the session data
export const sessionQueryKey = ['gefakit-session'] as const; // Use 'as const' for type safety

export function useAuthSession() {
  const { data, isLoading, isFetching, error, refetch, isError } = useQuery({
    queryKey: sessionQueryKey,
    queryFn: apiGetSession,
    // Common options for session queries:
    staleTime: 5 * 60 * 1000, // 5 minutes - How long data is considered fresh
    gcTime: 15 * 60 * 1000, // 15 minutes - How long data stays in cache after unused
    retry: 1, // Don't retry endlessly on auth errors
    refetchOnWindowFocus: true, // Refetch when user comes back to the tab
    refetchInterval: false, // No automatic polling unless needed
  });

  return {
    data: data, // Will be user data object or null
    isLoading: isLoading, // Initial load
    isFetching: isFetching, // Loading on background refetch
    error,
    isError,
    refetchSession: refetch, // Expose refetch function if manual refresh is needed
    isAuthenticated: !!data, // Simple boolean check if session data exists
  };
}

================
File: apps/web/src/features/auth/api.ts
================
import { SessionDTO, SignUpEmailRequestBodyDTO, UserDTO } from "@gefakit/shared";

const API_BASE_URL = 'http://localhost:8787/api/v1/auth';

export const apiGetSession = async (): Promise<{ session: SessionDTO; user: UserDTO } | null> => {
  try {
    const response = await fetch(`${API_BASE_URL}/session`, {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
      },
      credentials: 'include', 
    });

    //  Handle explicit "No Session Cookie" case
    if (response.status === 401) {
      console.log('Session check: 401 - No session cookie found or sent.');
      return null;
    }

    // Handle other non-successful responses (like 500 Internal Server Error)
    if (!response.ok) {
      // Throwing here allows useQuery to catch it and set its error state
      throw new Error(`Failed to fetch session: Server responded with ${response.status}`);
    }

    // Handle successful response (200 OK)
    const data = await response.json();

    // If user and session are present and not null, we are authenticated.
    if (data && data.user && data.session) {
      // console.log('Session check: Valid session found.');
      return data as { session: SessionDTO; user: UserDTO };
    } else {
      console.log('Session check: 200 OK, but session/user data is null (invalid/expired token).');
      return null; // Treat as not authenticated
    }

  } catch (error) {
    // Handles network errors or the error thrown from !response.ok
    console.error("Error during apiGetSession fetch:", error);
    // Re-throw the error. useQuery will catch this and set its state accordingly (isError, error)
    // This is generally better than returning null for network/server errors,
    // as it differentiates between "logged out" and "system unavailable".
    throw error;
  }
};

export const apiSignInEmail = async ({ email, password }: { email: string, password: string }) => {
  const response = await fetch(`${API_BASE_URL}/sign-in/email`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, password }),
    credentials: 'include',
  });
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({ message: 'Failed to sign in' }));
    throw new Error(errorData.message || 'Sign in failed');
  }
  return response.json();
};

export const apiSignUpEmail = async ({ username, email, password }: SignUpEmailRequestBodyDTO) => {
  const response = await fetch(`${API_BASE_URL}/sign-up/email`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ username, email, password }),
  });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({ message: 'Failed to sign up' }));
    throw new Error(errorData.message || 'Sign up failed');
  }

  return response.json();
};



export const apiSignOut = async () => {
  const response = await fetch(`${API_BASE_URL}/sign-out`, {
    method: 'POST',
    credentials: 'include',
  });
   if (!response.ok) {
    const errorData = await response.json().catch(() => ({ message: 'Failed to sign out' }));
    throw new Error(errorData.message || 'Sign out failed');
  }
  return response.json();
};

================
File: apps/web/src/App.css
================
#root {
	max-width: 1280px;
	margin: 0 auto;
	padding: 2rem;
	text-align: center;
}

.logo {
	height: 6em;
	padding: 1.5em;
	will-change: filter;
	transition: filter 300ms;
}
.logo:hover {
	filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
	filter: drop-shadow(0 0 2em #61dafbaa);
}
.logo.cloudflare:hover {
	filter: drop-shadow(0 0 2em #f6821faa);
}

@keyframes logo-spin {
	from {
		transform: rotate(0deg);
	}
	to {
		transform: rotate(360deg);
	}
}

@media (prefers-reduced-motion: no-preference) {
	a:nth-of-type(2) .logo {
		animation: logo-spin infinite 20s linear;
	}
}

.card {
	padding: 2em;
}

.read-the-docs {
	color: #888;
}

================
File: apps/web/src/index.css
================
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.147 0.004 49.25);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.147 0.004 49.25);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.147 0.004 49.25);
  --primary: oklch(0.216 0.006 56.043);
  --primary-foreground: oklch(0.985 0.001 106.423);
  --secondary: oklch(0.97 0.001 106.424);
  --secondary-foreground: oklch(0.216 0.006 56.043);
  --muted: oklch(0.97 0.001 106.424);
  --muted-foreground: oklch(0.553 0.013 58.071);
  --accent: oklch(0.97 0.001 106.424);
  --accent-foreground: oklch(0.216 0.006 56.043);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.923 0.003 48.717);
  --input: oklch(0.923 0.003 48.717);
  --ring: oklch(0.709 0.01 56.259);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0.001 106.423);
  --sidebar-foreground: oklch(0.147 0.004 49.25);
  --sidebar-primary: oklch(0.216 0.006 56.043);
  --sidebar-primary-foreground: oklch(0.985 0.001 106.423);
  --sidebar-accent: oklch(0.97 0.001 106.424);
  --sidebar-accent-foreground: oklch(0.216 0.006 56.043);
  --sidebar-border: oklch(0.923 0.003 48.717);
  --sidebar-ring: oklch(0.709 0.01 56.259);
}

.dark {
  --background: oklch(0.147 0.004 49.25);
  --foreground: oklch(0.985 0.001 106.423);
  --card: oklch(0.216 0.006 56.043);
  --card-foreground: oklch(0.985 0.001 106.423);
  --popover: oklch(0.216 0.006 56.043);
  --popover-foreground: oklch(0.985 0.001 106.423);
  --primary: oklch(0.923 0.003 48.717);
  --primary-foreground: oklch(0.216 0.006 56.043);
  --secondary: oklch(0.268 0.007 34.298);
  --secondary-foreground: oklch(0.985 0.001 106.423);
  --muted: oklch(0.268 0.007 34.298);
  --muted-foreground: oklch(0.709 0.01 56.259);
  --accent: oklch(0.268 0.007 34.298);
  --accent-foreground: oklch(0.985 0.001 106.423);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.553 0.013 58.071);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.216 0.006 56.043);
  --sidebar-foreground: oklch(0.985 0.001 106.423);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0.001 106.423);
  --sidebar-accent: oklch(0.268 0.007 34.298);
  --sidebar-accent-foreground: oklch(0.985 0.001 106.423);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.553 0.013 58.071);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================
File: apps/web/src/main.tsx
================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

================
File: apps/web/src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: apps/web/worker/index.ts
================
export default {
  fetch(request) {
    const url = new URL(request.url);

    if (url.pathname.startsWith("/api/")) {
      return Response.json({
        name: "Cloudflare",
      });
    }
		return new Response(null, { status: 404 });
  },
} satisfies ExportedHandler<Env>;

================
File: apps/web/.gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# wrangler files
.wrangler
.dev.vars*

.env*

================
File: apps/web/eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: apps/web/index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: apps/web/README.md
================
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config({
  extends: [
    // Remove ...tseslint.configs.recommended and replace with this
    ...tseslint.configs.recommendedTypeChecked,
    // Alternatively, use this for stricter rules
    ...tseslint.configs.strictTypeChecked,
    // Optionally, add this for stylistic rules
    ...tseslint.configs.stylisticTypeChecked,
  ],
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config({
  plugins: {
    // Add the react-x and react-dom plugins
    'react-x': reactX,
    'react-dom': reactDom,
  },
  rules: {
    // other rules...
    // Enable its recommended typescript rules
    ...reactX.configs['recommended-typescript'].rules,
    ...reactDom.configs.recommended.rules,
  },
})
```

================
File: apps/web/tsconfig.app.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": [
      "ES2020",
      "DOM",
      "DOM.Iterable"
    ],
    "module": "ESNext",
    "skipLibCheck": true,
    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./src/*"
      ]
    }
  },
  "include": [
    "src"
  ]
}

================
File: apps/web/tsconfig.json
================
{
	"files": [],
	"references": [
		{
			"path": "./tsconfig.app.json"
		},
		{
			"path": "./tsconfig.node.json"
		},
		{
			"path": "./tsconfig.worker.json"
		}
	],
	"compilerOptions": {
		"types": [
			"@cloudflare/workers-types/2023-07-01"
		],
		"baseUrl": ".",
		"paths": {
			"@/*": [
				"./src/*"
			]
		}
	}
}

================
File: apps/web/tsconfig.node.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: apps/web/tsconfig.worker.json
================
{
  "extends": "./tsconfig.node.json",
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.worker.tsbuildinfo",
    "types": [
      "@cloudflare/workers-types/2023-07-01",
      "./worker-configuration.d.ts",
      "vite/client"
    ],
  },
  "include": [
    "worker"
  ],
}

================
File: apps/web/vite.config.ts
================
import { defineConfig } from 'vite'
import tailwindcss from "@tailwindcss/vite"
import react from '@vitejs/plugin-react-swc'
import { cloudflare } from "@cloudflare/vite-plugin";
import path from 'path';

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss(), cloudflare()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
})

================
File: apps/web/wrangler.jsonc
================
/**
 * For more details on how to configure Wrangler, refer to:
 * https://developers.cloudflare.com/workers/wrangler/configuration/
 */
{
	"$schema": "node_modules/wrangler/config-schema.json",
	"name": "gefakit-web",
	"main": "worker/index.ts",
	"compatibility_date": "2025-04-09",
	"assets": {
		"not_found_handling": "single-page-application"
	},
	"observability": {
		"enabled": true
	},
	"vars": {
		"MY_VAR": "Top-level var 1"
	},
	"env": {
		"staging": {
			"vars": {
				"MY_VAR": "Staging var 1"
			}
		},
		"production": {
			"vars": {
				"MY_VAR": "Production var 1"
			}
		}
	}
	/**
	 * Smart Placement
	 * Docs: https://developers.cloudflare.com/workers/configuration/smart-placement/#smart-placement
	 */
	// "placement": { "mode": "smart" },
	/**
	 * Bindings
	 * Bindings allow your Worker to interact with resources on the Cloudflare Developer Platform, including
	 * databases, object storage, AI inference, real-time communication and more.
	 * https://developers.cloudflare.com/workers/runtime-apis/bindings/
	 */
	/**
	 * Environment Variables
	 * https://developers.cloudflare.com/workers/wrangler/configuration/#environment-variables
	 */
	// "vars": { "MY_VARIABLE": "production_value" },
	/**
	 * Note: Use secrets to store sensitive data.
	 * https://developers.cloudflare.com/workers/configuration/secrets/
	 */
	/**
	 * Static Assets
	 * https://developers.cloudflare.com/workers/static-assets/binding/
	 */
	// "assets": { "directory": "./public/", "binding": "ASSETS" },
	/**
	 * Service Bindings (communicate between multiple Workers)
	 * https://developers.cloudflare.com/workers/wrangler/configuration/#service-bindings
	 */
	// "services": [{ "binding": "MY_SERVICE", "service": "my-service" }]
}

================
File: packages/shared/src/schemas/auth.schema.ts
================
import { z } from 'zod';

export const userSchema = z.object({
    id: z.number(),
    email: z.string(),
    username: z.string().nullable().optional(),
    created_at: z.date(),
});

export const sessionSchema = z.object({
    id: z.string(),
    user_id: z.number(),
    expires_at: z.date()
});

export const getSessionResponseSchema = z.object({
    session: sessionSchema.nullable(),
    user: userSchema.nullable(),
});

export const signInEmailRequestBodySchema = z.object({
    email: z.string().email(),
    password: z.string(),
});

export const signInEmailResponseSchema = z.object({
    user: userSchema,
});

export const signUpEmailRequestBodySchema = z.object({
    username: z.string(),
    email: z.string().email(),
    password: z.string(),
});

export const signUpEmailResponseSchema = z.object({
    user: userSchema,
});

export const signOutResponseSchema = z.object({
    message: z.string(),
});

================
File: packages/shared/src/types/auth.ts
================
import { 
  userSchema,
  sessionSchema,
  getSessionResponseSchema,
  signInEmailRequestBodySchema,
  signUpEmailRequestBodySchema, 
  signUpEmailResponseSchema} from "../schemas/auth.schema";
import { z } from "zod";

export type UserDTO = z.infer<typeof userSchema>;
export type SessionDTO = z.infer<typeof sessionSchema>;

export type GetSessionResponseDTO = z.infer<typeof getSessionResponseSchema>;

export type SignInEmailRequestBodyDTO = z.infer<typeof signInEmailRequestBodySchema>;
export type SignInEmailResponseDTO = { user: UserDTO };

export type SignUpEmailRequestBodyDTO = z.infer<typeof signUpEmailRequestBodySchema>;
export type SignUpEmailResponseDTO = z.infer<typeof signUpEmailResponseSchema>;

export type SignOutResponseDTO = { message: string };

================
File: packages/shared/src/types/user.ts
================
export interface TestType {
    id: string;
    email: string;
    name: string;
    role: TestTypeRole;
  }
  

export const TestTypeRole = {
    ADMIN: 'admin',
    USER: 'user',
} as const;

export type TestTypeRole = typeof TestTypeRole[keyof typeof TestTypeRole];

================
File: packages/shared/.gitignore
================
node_modules
dist

================
File: packages/shared/package.json
================
{
    "name": "@gefakit/shared",
    "version": "1.0.0",
    "main": "src/index.ts",
    "types": "src/index.ts",
    "scripts": {
        "build": "tsc"
    },
    "dependencies": {
        "zod": "^3.24.2"
    },
    "devDependencies": {
        "typescript": "^5.8.3"
    }
}

================
File: packages/shared/tsconfig.json
================
{
    "compilerOptions": {
        "target": "ES2019",
        "module": "commonjs",
        "declaration": true,
        "outDir": "dist",
        "strict": true,
        "esModuleInterop": true
    },
    "include": [
        "src"
    ]
}

================
File: .gitignore
================
node_modules

.env
.env.local
.env.development.local
.env.test.local
.env.production.local

.DS_Store

ai-project-info.txt

================
File: package.json
================
{
    "name": "gefakit",
    "version": "0.0.0",
    "private": true,
    "workspaces": [
        "apps/*",
        "packages/*"
    ],
    "scripts": {
        "dev:web": "pnpm --filter gefakit-web dev",
        "dev:api": "pnpm --filter gefakit-api dev:all"
    },
    "packageManager": "pnpm@10.8.0"
}

================
File: apps/api/src/db/migrations/0001_init.ts
================
// import { Kysely, sql } from 'kysely'

// export async function up(db: Kysely<any>): Promise<void> {
//   await db.schema
//     .createTable('person')
//     .addColumn('id', 'serial', (col) => col.primaryKey())
//     .addColumn('first_name', 'varchar', (col) => col.notNull())
//     .addColumn('last_name', 'varchar')
//     .addColumn('gender', 'varchar(50)', (col) => col.notNull())
//     .addColumn('created_at', 'timestamp', (col) =>
//       col.defaultTo(sql`now()`).notNull(),
//     )
//     .execute()

//   await db.schema
//     .createTable('pet')
//     .addColumn('id', 'serial', (col) => col.primaryKey())
//     .addColumn('name', 'varchar', (col) => col.notNull().unique())
//     .addColumn('owner_id', 'integer', (col) =>
//       col.references('person.id').onDelete('cascade').notNull(),
//     )
//     .addColumn('species', 'varchar', (col) => col.notNull())
//     .execute()

//   await db.schema
//     .createIndex('pet_owner_id_index')
//     .on('pet')
//     .column('owner_id')
//     .execute()
// }

// export async function down(db: Kysely<any>): Promise<void> {
//   await db.schema.dropTable('pet').execute()
//   await db.schema.dropTable('person').execute()
// }

/**
 * CREATE TABLE app_user (
    id SERIAL PRIMARY KEY,
    username TEXT NOT NULL UNIQUE
);

CREATE TABLE user_session (
    id TEXT NOT NULL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES app_user(id),
    expires_at TIMESTAMPTZ NOT NULL,
);
 */

import { Kysely } from 'kysely'

export async function up(db: Kysely<any>): Promise<void> {
  await db.schema
    .createTable('app_user')
    .addColumn('id', 'serial', (col) => col.primaryKey())
    .addColumn('username', 'text', (col) => col.notNull().unique())
    .execute()

  await db.schema
    .createTable('user_session')
    .addColumn('id', 'text', (col) => col.primaryKey())
    .addColumn('user_id', 'integer', (col) =>
      col.references('app_user.id').notNull()
    )
    .addColumn('expires_at', 'timestamptz', (col) => col.notNull())
    .execute()
}

export async function down(db: Kysely<any>): Promise<void> {
  await db.schema.dropTable('user_session').execute()
  await db.schema.dropTable('app_user').execute()
}

================
File: apps/api/src/db/db-types.d.ts
================
/**
 * This file was generated by kysely-codegen.
 * Please do not edit it manually.
 */

import type { ColumnType } from "kysely";

export type Generated<T> = T extends ColumnType<infer S, infer I, infer U>
  ? ColumnType<S, I | undefined, U>
  : ColumnType<T, T | undefined, T>;

export type Timestamp = ColumnType<Date, Date | string, Date | string>;

export interface AppUser {
  created_at: Generated<Timestamp>;
  email: string;
  id: Generated<number>;
  password_hash: string;
  recovery_code: Buffer | null;
  username: string;
}

export interface Todo {
  author_id: number;
  completed: Generated<boolean>;
  created_at: Generated<Timestamp>;
  description: string | null;
  due_date: Timestamp | null;
  id: Generated<number>;
  title: string;
}

export interface UserSession {
  expires_at: Timestamp;
  id: string;
  user_id: number;
}

export interface DB {
  app_user: AppUser;
  todo: Todo;
  user_session: UserSession;
}

================
File: apps/api/wrangler.jsonc
================
/**
 * For more details on how to configure Wrangler, refer to:
 * https://developers.cloudflare.com/workers/wrangler/configuration/
 */
{
	"$schema": "node_modules/wrangler/config-schema.json",
	"name": "gefakit-api",
	"main": "src/index.ts",
	"compatibility_date": "2025-04-08",
	"compatibility_flags": [
		"nodejs_compat"
	],
	"assets": {
		"binding": "ASSETS",
		"directory": "./public"
	},
	"placement": {
		"mode": "smart"
	},
	"observability": {
		"enabled": true
	},
	"vars": {
		"DB_ENV": "development"
	},
	"d1_databases": [
		{
			"binding": "DB",
			"database_name": "gefakit-db-development",
			"database_id": "dac494ad-023c-4959-93b9-123f792f36cd",
			"migrations_dir": "./src/db/migrations"
		}
	],
	"kv_namespaces": [
		{
			"binding": "KV",
			"id": "f0217db8f2b54628baa26e0a2d8f97f1"
		}
	],
	"env": {
		"staging": {
			"vars": {
				"DB_ENV": "staging"
			},
			"d1_databases": [
				{
					"binding": "DB",
					"database_name": "gefakit-db-staging",
					"database_id": "8def47e0-4fb8-41bb-8c75-858f0ca20474",
					"migrations_dir": "./src/db/migrations"
				}
			],
			"kv_namespaces": [
				{
					"binding": "KV",
					"id": "e54d39e0b71f40609e438f4f871f690d"
				}
			]
		},
		"production": {
			"vars": {
				"DB_ENV": "production"
			},
			"d1_databases": [
				{
					"binding": "DB",
					"database_name": "gefakit-db-production",
					"database_id": "3e46b69c-754f-4c03-82b9-033cd50f6ea7",
					"migrations_dir": "./src/db/migrations"
				}
			],
			"kv_namespaces": [
				{
					"binding": "KV",
					"id": "fcd4f648528b42e19c1504f75332ae74"
				}
			]
		}
	},
	/**
	 * Smart Placement
	 * Docs: https://developers.cloudflare.com/workers/configuration/smart-placement/#smart-placement
	 */
	// "placement": { "mode": "smart" },
	/**
	 * Bindings
	 * Bindings allow your Worker to interact with resources on the Cloudflare Developer Platform, including
	 * databases, object storage, AI inference, real-time communication and more.
	 * https://developers.cloudflare.com/workers/runtime-apis/bindings/
	 */
	/**
	 * Environment Variables
	 * https://developers.cloudflare.com/workers/wrangler/configuration/#environment-variables
	 */
	// "vars": { "MY_VARIABLE": "production_value" },
	/**
	 * Note: Use secrets to store sensitive data.
	 * https://developers.cloudflare.com/workers/configuration/secrets/
	 */
	/**
	 * Static Assets
	 * https://developers.cloudflare.com/workers/static-assets/binding/
	 */
	// "assets": { "directory": "./public/", "binding": "ASSETS" },
	/**
	 * Service Bindings (communicate between multiple Workers)
	 * https://developers.cloudflare.com/workers/wrangler/configuration/#service-bindings
	 */
	// "services": [{ "binding": "MY_SERVICE", "service": "my-service" }]
}

================
File: packages/shared/src/index.ts
================
export * from "./schemas/user.schema";
export * from "./schemas/representative.schema";
export * from "./schemas/vehicle.schema";
export * from "./schemas/subscription.schema";

export * from "./types/user";
export * from "./types/auth";

================
File: pnpm-workspace.yaml
================
packages:
  - apps/*
  - packages/*

ignoredBuiltDependencies:
  - '@swc/core'
  - esbuild
  - sharp
  - workerd

onlyBuiltDependencies:
  - better-sqlite3

================
File: apps/api/src/features/persons/person.routes.v1.ts
================
import { Hono } from "hono";
import { jsonArrayFrom } from 'kysely/helpers/postgres'
import { Bindings } from "../../types/hono";
import { Variables } from "../../types/hono";
import { getCookie } from "hono/cookie";
import { createAuthService } from "../auth/auth.service";
import { createAppError } from "../../errors";


const app = new Hono<{ Bindings: Bindings, Variables: Variables }>();

app.get("/", async (c) => {
    const db = c.get("db");

    const sessionToken = getCookie(c, 'gefakit-session');

    if (!sessionToken) {
        throw createAppError.auth.unauthorized();
    }

    console.log('sessionToken: ', sessionToken)
    
    const authService = createAuthService(db);
    const {session} = await authService.getCurrentSession(sessionToken);

    if (!session) {
        throw createAppError.auth.unauthorized();
    }
   
     const persons = await db
      .selectFrom('app_user')
      .selectAll()
      .execute();

    return c.json({ persons });
});


app.get('/:id', async (c) => {
    const id = c.req.param('id')

    console.log('id: ', id);
    const KV = c.env.KV;
    const kv = await KV.get('myKey');

    return c.json({ id, kv });
  })

export const personRoutesV1 = app;

================
File: apps/api/src/middleware/db.ts
================
import { createMiddleware } from 'hono/factory'
import { Kysely } from 'kysely'
import { NeonDialect } from 'kysely-neon';
import { DB } from '../db/db-types';
import { Bindings } from '../types/hono';

export interface DbMiddleWareVariables {
  db: Kysely<DB>
}

export const dbMiddleware = createMiddleware<{ Bindings: Bindings, Variables: DbMiddleWareVariables }>(async (c, next) => {
    const db = new Kysely<DB>({
      dialect: new NeonDialect({
        connectionString: process.env.DATABASE_URL_POOLED,
      }),
    })
    c.set('db', db);
    await next()
  })

================
File: apps/api/src/types/hono.ts
================
export interface Bindings extends Cloudflare.Env {
    myVar: string;
}

================
File: apps/web/src/App.tsx
================
// App.tsx (or wherever AppContent is)
import { useState } from 'react'; // Removed useEffect unless needed for other things
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import './App.css';
// Import your new hooks
import { TodoView } from './features/todos/components/todo-view';
import { useAuth } from './features/auth/hooks/useAuth';

const queryClient = new QueryClient();

function AppContent() {
  const [count, setCount] = useState(0); // Keep local UI state if needed

  // Get auth action functions and states
  const {
    signInEmail,
    signUpEmail,
    signOut,
    signInSocial,
    isSigningIn,
    isSigningUp,
    isSigningOut,
    session,
    isLoadingSession,
    sessionError,
    isAuthenticated,
  } = useAuth();

  const handleFetchPersons = async () => {
    console.log('Fetching persons...');
    try {
      const res = await fetch('http://localhost:8787/api/v1/persons', {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include', // Requires user to be logged in on backend
      });
      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`);
      }
      const data = await res.json();
      console.log('Persons data: ', data);
    } catch (error) {
      console.error("Failed to fetch persons:", error);
      // Handle error (e.g., show message) - likely needs authentication
    }
  };

  // Example data for forms
  const email = 'john@example.com';
  const password = '1q2w3eeqoidj4r';
  const username = 'John';

  return (
    <>
      <h1>Auth Actions & Session State</h1>

      {/* Display Session Info */}
      <div>
        <h2>Session Status:</h2>
        {isLoadingSession && <p>Loading session...</p>}
        {sessionError && <p style={{ color: 'red' }}>Error loading session: {sessionError.message}</p>}
        {isAuthenticated && session && (
          <div>
            <p>Welcome, {session.user.username || session.user.email}!</p>
            <pre>{JSON.stringify(session, null, 2)}</pre>
          </div>
        )}
        {!isLoadingSession && !isAuthenticated && <p>You are not logged in.</p>}
      </div>

      {/* Auth Actions */}
      <div>
        <h2>Actions:</h2>
        {!isAuthenticated && (
          <>
            <button onClick={() => signUpEmail({ username, email, password })} disabled={isSigningUp}>
              {isSigningUp ? 'Signing Up...' : 'Sign Up Email'}
            </button>
            <button onClick={() => signInEmail({ email, password })} disabled={isSigningIn}>
              {isSigningIn ? 'Signing In...' : 'Sign In Email'}
            </button>
            <button onClick={() => signInSocial('github')}>
              Sign In with GitHub
            </button>
          </>
        )}
        {isAuthenticated && (
          <button onClick={() => signOut()} disabled={isSigningOut}>
            {isSigningOut ? 'Signing Out...' : 'Sign Out'}
          </button>
        )}
      </div>

      {/* Protected Action Example */}
      <div>
        <h2>Protected Data:</h2>
        {isAuthenticated && (
          <button onClick={handleFetchPersons}>Fetch Persons (Protected)</button>
        )}
        {!isAuthenticated && (
          <>
            <p>Log in to fetch persons data.</p>
            <button onClick={handleFetchPersons}>Fetch Persons anyway (Protected)</button>
          </>
        )}
      </div>

      <div className='mt-8'>
        {isAuthenticated && <TodoView />}
      </div>

    </>
  );
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <AppContent />
    </QueryClientProvider>
  );
}

export default App;

================
File: apps/web/package.json
================
{
	"name": "gefakit-web",
	"private": true,
	"version": "0.0.0",
	"type": "module",
	"scripts": {
		"dev": "vite",
		"build:staging": "tsc -b && vite build --mode staging",
		"build:production": "tsc -b && vite build --mode production",
		"deploy:staging": "CLOUDFLARE_ENV=staging npm run build:staging && wrangler deploy",
		"deploy:production": "CLOUDFLARE_ENV=production npm run build:production && wrangler deploy",
		"preview": "npm run build && vite preview",
		"lint": "eslint .",
		"cf-typegen": "wrangler types"
	},
	"dependencies": {
		"@gefakit/shared": "workspace:*",
		"@radix-ui/react-checkbox": "^1.1.5",
		"@radix-ui/react-label": "^2.1.3",
		"@radix-ui/react-slot": "^1.2.0",
		"@tailwindcss/vite": "^4.1.4",
		"@tanstack/react-form": "^1.4.1",
		"@tanstack/react-query": "^5.74.3",
		"class-variance-authority": "^0.7.1",
		"clsx": "^2.1.1",
		"lucide-react": "^0.488.0",
		"react": "^19.0.0",
		"react-dom": "^19.0.0",
		"tailwind-merge": "^3.2.0",
		"tailwindcss": "^4.1.4",
		"tw-animate-css": "^1.2.5"
	},
	"devDependencies": {
		"@cloudflare/vite-plugin": "^1.0.5",
		"@cloudflare/workers-types": "^4.20250410.0",
		"@eslint/js": "^9.21.0",
		"@types/node": "^22.14.0",
		"@types/react": "^19.0.10",
		"@types/react-dom": "^19.0.4",
		"@vitejs/plugin-react-swc": "^3.8.0",
		"eslint": "^9.21.0",
		"eslint-plugin-react-hooks": "^5.1.0",
		"eslint-plugin-react-refresh": "^0.4.19",
		"globals": "^15.15.0",
		"typescript": "~5.7.2",
		"typescript-eslint": "^8.24.1",
		"vite": "^6.2.0",
		"wrangler": "^4.10.0"
	}
}

================
File: apps/api/src/index.ts
================
import { Hono } from "hono";
import { Bindings } from "./types/hono";
import { dbMiddleware } from "./middleware/db";
import { personRoutesV1 } from "./features/persons/person.routes.v1";
import { authRoutesV1 } from "./features/auth/auth.routes.v1";
import { ZodError } from "zod";
import { AppError } from "./errors/app-error";
import { todoRoutesV1 } from "./features/todos/todo.routes.v1";
import { authMiddleware } from "./middleware/auth";

const app = new Hono<{ Bindings: Bindings}>();

app.use('/api/*', async (c, next) => {
  c.header('Access-Control-Allow-Origin', 'http://localhost:5173'); // Replace with your frontend domain
  c.header('Access-Control-Allow-Credentials', 'true');
  c.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  c.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS'); 
  if (c.req.method === 'OPTIONS') {
    // Return OK status for preflight requests
    return c.text('OK', 200); 
  }
  await next();
});

// All routes will have access to the db instance.
app.use('/api/*', dbMiddleware);


app.route("/api/v1/persons", personRoutesV1);
app.route("/api/v1/auth", authRoutesV1);

// Apply auth middleware ONLY to todo routes
app.use("/api/v1/todos/*", authMiddleware); 
app.route("/api/v1/todos", todoRoutesV1);

app.notFound((c) => {
  return c.text('This route does not exist', 404);
});

app.onError((err, c) => {
  console.log('===================== onError =====================');
  console.log('===================== onError =====================');
  console.log('===================== onError =====================');
  console.log('===================== onError =====================');
  console.log('===================== onError =====================');
  console.log('===================== onError =====================');
  console.log('===================== onError =====================');
  console.log('===================== onError =====================');
   console.error('App Error:', err);
  
  
  if (err instanceof ZodError) {
    console.log('IT IS A ZOD ERROR (direct)');
    return c.json({
      ok: false,
      errors: err.errors.map(e => ({
        field: e.path.join('.'),
        message: e.message
      }))
    }, 400);
  }

  // Check if the error is an HTTPException with a ZodError cause
  // Note: We might need to import HTTPException from 'hono/http-exception'
  //       or just check for the presence and type of the 'cause' property.
  //       Let's try checking the property first for simplicity.
  if (err instanceof Error && err.cause instanceof ZodError) {
    console.log('IT IS A ZOD ERROR (wrapped in HTTPException)');
    const zodError = err.cause;
    return c.json({
      ok: false,
      errors: zodError.errors.map(e => ({
        field: e.path.join('.'),
        message: e.message
      }))
    }, 400); // Use 400 for validation errors
  }

  console.log('it is not a zod error');

  if (err instanceof AppError) {
    const statusCode = typeof err.status === 'number' && err.status >= 100 && err.status <= 599 
      ? err.status 
      : 500;
    return c.json({ 
      ok: false, 
      errorMessage: err.message,
      errorDetails: err.details 
    }, statusCode as any);
  }

  return c.json({ ok: false, error: "Internal Server Error" }, 500);
});

export default app;

================
File: README.md
================
# GefaKit
The 5$ fullstack framework for quickly prototyping your next big idea.

## Features
- [ ] Landing Page
- [ ] Authentication
- [ ] Database
- [ ] API
- [ ] Admin Panel
- [ ] Users & Organizations
- [ ] Billing
- [ ] Localization
- [ ] Emails
- [ ] Uploads



## DEV

- Clone the repo. Not really... run `create-gefakit@latest` and follow the instructions.



## Steps I should take after cloning (Could be automated)
All steps include dev-staging-production. You can skip the staging steps for a quicker dev-production cycle.
You can always add staging later.

NOTE: We intentionally don't use `preview` from cloudflare for databases and KV namespaces because it's easier to manage different environments.

## Databses D1 - NOT USED

1. Create a new D1 dev database with: `wrangler d1 create gefakit-db-development`
2. Create a new D1 staging database with: `wrangler d1 create gefakit-db-staging`
3. Create a new D1 production database with: `wrangler d1 create gefakit-db-production`
This will return something like the following, add the database_id for each environment to the `wrangler.jsonc` file.
```
{
  "d1_databases": [
    {
      "binding": "DB",
      "database_name": "gefakit-db",
      "database_id": "12345678-1234-1234-1234-123456789012"
    }
  ]
}
```

NOTE: Need to run `npm run types` to generate the types for the database.

3. Make sure the first migration is what you want at `/src/db/migrations/0001_init.sql`. Run `npm run db:migrate:local` to apply the migrations.
Similar, you can run `npm run db:migrate:staging` and `npm run db:migrate:production` to apply the migrations to the staging and production databases.

4. Run `npm run db:seed:local` to seed the database.
Similar, you can run `npm run db:seed:staging` and `npm run db:seed:production` to seed the staging and production databases.

## DATABASES - NEON POSTGRES
Create a seperate database for each environment and set the connection strings in:
.dev.vars => DATABASE_URL and DATABASE_URL_POOLED for development
.dev.vars => DATABASE_URL and DATABASE_URL_POOLED for staging
.dev.vars => DATABASE_URL and DATABASE_URL_POOLED for production

Note: Remember to set the secrets to cloudflare environments:
`npx wrangler secret put BUCKET_APPDRIVE_PUBLIC_NAME --env staging`

Note: The development development is on-purpose

## KV
1. Create KV name space `GEFAKIT_KV` with `npx wrangler kv namespace create gefakit-kv-development`
2. Create KV name space `GEFAKIT_KV` with `npx wrangler kv namespace create gefakit-kv-staging`
3. Create KV name space `GEFAKIT_KV` with `npx wrangler kv namespace create gefakit-kv-production`

Similar to the databases, this will return something like the following, add the kv_id for each environment to the `wrangler.jsonc` file.
```
{
  "kv_namespaces": [
    {
      "binding": "gefakit_kv_development",
      "id": "65a90d4f536f4c619b49df8fc663695e"
    }
  ]
}
```

================
File: apps/api/package.json
================
{
	"name": "gefakit-api",
	"scripts": {
		"dev": "wrangler dev",
		"dev:staging": "wrangler dev --remote --env staging",
		"dev:production:yes-i-am-sure": "wrangler dev --remote --env production",
		"deploy:staging": "wrangler deploy --minify --env staging",
		"deploy:production:yes-i-am-sure": "wrangler deploy --minify --env production",
		"cf-typegen": "wrangler types --env-interface CloudflareBindings",
		"types": "wrangler types",
		"db:codegen:development": "kysely-codegen --dialect postgres --env-file .dev.vars --out-file ./src/db/db-types.d.ts",
		"db:codegen:staging": "kysely-codegen --dialect postgres --env-file .dev.vars.staging --out-file ./src/db/db-types.d.ts",
		"db:codegen:production:yes-i-am-sure": "kysely-codegen --dialect postgres --env-file .dev.vars.production --out-file ./src/db/db-types.d.ts",
		"db:migrate:development": "cross-env NODE_ENV=development tsx ./src/db/migrate.ts",
		"db:migrate:staging": "cross-env NODE_ENV=staging tsx ./src/db/migrate.ts",
		"db:migrate:production:yes-i-am-sure": "cross-env NODE_ENV=production tsx ./src/db/migrate.ts",
		"db:migrate:down:development": "cross-env NODE_ENV=development tsx ./src/db/migrate-down.ts",
		"db:migrate:down:staging": "cross-env NODE_ENV=staging tsx ./src/db/migrate-down.ts",
		"db:migrate:down:production:yes-i-am-sure": "cross-env NODE_ENV=production tsx ./src/db/migrate-down.ts",
		"db:seed:file": "cross-env NODE_ENV=development tsx ./src/db/seeds/seed-runner.ts",
		"db:drop:development": "cross-env NODE_ENV=development tsx ./src/db/seeds/drop.ts",
		"db:drop:staging": "cross-env NODE_ENV=staging tsx ./src/db/seeds/drop.ts",
		"db:drop:production:yes-i-am-sure": "cross-env NODE_ENV=production tsx ./src/db/seeds/drop.ts"
	},
	"dependencies": {
		"@gefakit/shared": "workspace:*",
		"@hono/zod-validator": "^0.4.3",
		"@neondatabase/serverless": "^1.0.0",
		"@node-rs/argon2": "^2.0.2",
		"@oslojs/binary": "^1.0.0",
		"@oslojs/crypto": "^1.0.1",
		"@oslojs/encoding": "^1.1.0",
		"bcryptjs": "^3.0.2",
		"cross-env": "^7.0.3",
		"hono": "^4.7.5",
		"kysely": "^0.27.6",
		"kysely-neon": "^1.3.0",
		"pg": "^8.14.1",
		"zod": "^3.24.2"
	},
	"devDependencies": {
		"@cloudflare/workers-types": "^4.20250410.0",
		"@faker-js/faker": "^9.7.0",
		"@types/node": "^22.14.0",
		"@types/pg": "^8.11.12",
		"dotenv": "^16.5.0",
		"kysely-codegen": "^0.18.3",
		"tsx": "^4.19.3",
		"wrangler": "^4.10.0"
	}
}



================================================================
End of Codebase
================================================================
